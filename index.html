
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Vue实验室</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="用一年的时间好好搞定Vue，已Vue为支点撬动前端知识体系。">
<meta property="og:type" content="website">
<meta property="og:title" content="Vue实验室">
<meta property="og:url" content="https://violetjack.github.io/index.html">
<meta property="og:site_name" content="Vue实验室">
<meta property="og:description" content="用一年的时间好好搞定Vue，已Vue为支点撬动前端知识体系。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue实验室">
<meta name="twitter:description" content="用一年的时间好好搞定Vue，已Vue为支点撬动前端知识体系。">
  
    <link rel="alternative" href="/atom.xml" title="Vue实验室" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Vue实验室</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">专注于Vue相关知识的学习和分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="violetjack.github.io">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Vue.js源码学习四 —— 渲染 Render 初始化过程学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/19/Vue.js源码学习四 —— 渲染 Render 初始化过程学习/" class="article-date">
  <time datetime="2018-02-18T16:00:00.000Z" itemprop="datePublished">2018-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/19/Vue.js源码学习四 —— 渲染 Render 初始化过程学习/">Vue.js源码学习四 —— 渲染 Render 初始化过程学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>今天我们来学习下Vue的渲染 Render 源码~</p>
</blockquote>
<p>还是从初始化方法开始找代码，在 <code>src/core/instance/index.js</code> 中，先执行了 <code>renderMixin</code> 方法，然后在Vue实例化的时候执行了 <code>vm._init</code> 方法，在这个 <code>vm._init</code> 方法中执行了 <code>initRender</code> 方法。<code>renderMixin</code> 和 <code>initRender</code> 都在 <code>src/core/instance/render.js</code> 中，我们来看看代码：</p>
<h1 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin"></a>renderMixin</h1><p>首先来跟一下 <code>renderMixin</code> 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export function renderMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  installRenderHelpers(Vue.prototype)</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$nextTick = function (fn: Function) &#123;</span><br><span class="line">    return nextTick(fn, this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._render = function (): VNode &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // vm.$options.render &amp; vm.$options._parentVnode</span><br><span class="line">    const &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      // 执行 vue 实例的 render 方法</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      handleError(e, vm, `render`)</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        if (vm.$options.renderError) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, vm, `renderError`)</span><br><span class="line">            vnode = vm._vnode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回空vnode避免render方法报错退出</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    // 父级Vnode</span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码执行了 <code>installRenderHelpers</code> 方法，然后定义了 Vue 的 <code>$nextTick</code> 和 <code>_render</code> 方法。<br>先来看看 <code>installRenderHelpers</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export function installRenderHelpers (target: any) &#123;</span><br><span class="line">  target._o = markOnce</span><br><span class="line">  target._n = toNumber // 数字</span><br><span class="line">  target._s = toString // 字符串</span><br><span class="line">  target._l = renderList // 列表</span><br><span class="line">  target._t = renderSlot</span><br><span class="line">  target._q = looseEqual</span><br><span class="line">  target._i = looseIndexOf</span><br><span class="line">  target._m = renderStatic</span><br><span class="line">  target._f = resolveFilter</span><br><span class="line">  target._k = checkKeyCodes</span><br><span class="line">  target._b = bindObjectProps</span><br><span class="line">  target._v = createTextVNode</span><br><span class="line">  target._e = createEmptyVNode</span><br><span class="line">  target._u = resolveScopedSlots</span><br><span class="line">  target._g = bindObjectListeners</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是 Vue 的各类渲染方法了，从字面意思中可以知道一些方法的用途，这些方法用在Vue生成的渲染函数中。具体各个渲染函数的实现先不提~之后会专门写博客学习。<br>在 <code>$nextTick</code> 函数中执行了 <code>nextTick</code> 函数，找到该函数源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &apos;nextTick&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在来说关键的 <code>_render</code> 方法，关键在这个 try…catch 方法中，执行了Vue实例中的 render 方法生成一个vnode。如果生成失败，会试着生成 renderError 方法。如果vnode为空，则为vnode传一个空的VNode，最后返回vnode对象。</p>
<h1 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a>initRender</h1><p>接下来看下 render 的初始化过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span> <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="keyword">const</span> parentVnode = vm.$vnode = options._parentVnode <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  vm.$scopedSlots = emptyObject</span><br><span class="line">  <span class="comment">// 将 createElement 方法绑定到这个实例，这样我们就可以在其中得到适当的 render context。</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 规范化一直应用于公共版本，用于用户编写的 render 函数。</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// 父级组件数据</span></span><br><span class="line">  <span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line">  <span class="comment">// 监听事件</span></span><br><span class="line">  defineReactive(vm, <span class="string">'$attrs'</span>, parentData &amp;&amp; parentData.attrs || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  defineReactive(vm, <span class="string">'$listeners'</span>, options._parentListeners || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 initRender 方法中，为Vue的实例方法添加了几个属性值，最后定义了 <code>$attrs</code> 和 <code>$listeners</code> 的监听方法。<br>看下 <code>createElement</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/core/vdom/create-element.js</span><br><span class="line">export function createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag: any,</span><br><span class="line">  data: any,</span><br><span class="line">  children: any,</span><br><span class="line">  normalizationType: any,</span><br><span class="line">  alwaysNormalize: boolean</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  if (Array.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = undefined</span><br><span class="line">  &#125;</span><br><span class="line">  if (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  return _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里执行了 <code>_createElement</code> 方法，由于该方法太长，就不贴出来费篇幅了，代码看<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/create-element.js#L47" target="_blank" rel="noopener">这里</a>。最终返回一个 VNode 对象，VNode 对象由 <code>createEmptyVNode</code> 或 <code>createComponent</code> 方法得到的。<br><code>createEmptyVNode</code> 创建了一个空的 VNode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/core/vdom/vnode.js</span><br><span class="line">export const createEmptyVNode = (text: string = &apos;&apos;) =&gt; &#123;</span><br><span class="line">  const node = new VNode()</span><br><span class="line">  node.text = text</span><br><span class="line">  node.isComment = true</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>createComponent</code> 创建了一个组件，最终也将返回一个 VNode 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// src/core/vdom/create-component.js</span><br><span class="line">export function createComponent (</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line">  if (isUndef(Ctor)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  const baseCtor = context.$options._base</span><br><span class="line">  if (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof Ctor !== &apos;function&apos;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let asyncFactory</span><br><span class="line">  if (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</span><br><span class="line">    if (Ctor === undefined) &#123;</span><br><span class="line">      return createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line">  resolveConstructorOptions(Ctor)</span><br><span class="line">  if (isDef(data.model)) &#123;</span><br><span class="line">    transformModel(Ctor.options, data)</span><br><span class="line">  &#125;</span><br><span class="line">  const propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br><span class="line">  if (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">    return createFunctionalComponent(Ctor, propsData, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const listeners = data.on</span><br><span class="line">  data.on = data.nativeOn</span><br><span class="line"></span><br><span class="line">  if (isTrue(Ctor.options.abstract)) &#123;</span><br><span class="line">    const slot = data.slot</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    if (slot) &#123;</span><br><span class="line">      data.slot = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mergeHooks(data)</span><br><span class="line">  // 创建组件的 VNode</span><br><span class="line">  const name = Ctor.options.name || tag</span><br><span class="line">  const vnode = new VNode(</span><br><span class="line">    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`,</span><br><span class="line">    data, undefined, undefined, undefined, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="初次渲染过程"><a href="#初次渲染过程" class="headerlink" title="初次渲染过程"></a>初次渲染过程</h1><p>既然是初次渲染，肯定会触发 <code>mounted</code> 生命周期钩子。所以我们从 <code>mount</code> 找起。在源码中定义了两次 <code>$mount</code> 方法，第一次返回了 <code>mountComponent</code> 方法；第二次定义了 Vue 实例的 <code>$options</code> 选项中的一些数据，然后再执行第一次的 <code>$mount</code> 方法，即执行 <code>mountComponent</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/platforms/web/runtime/index.js</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// src/platforms/web/entry-runtime-with-compiler.js</span><br><span class="line">const mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options = this.$options</span><br><span class="line">  // resolve template/el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template = options.template</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template === &apos;string&apos;) &#123;</span><br><span class="line">        if (template.charAt(0) === &apos;#&apos;) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 <code>compileToFunctions</code> 方法，该方法的作用是将 template 编译为 render 函数。<br><code>compileToFunctions</code> 方法是一个编译的过程，暂且不论。抓住主线，看渲染。所以去看看 <code>mountComponent</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  updateComponent = () =&gt; &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &apos;mounted&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在 beforeMount 和 mounted 生命周期之间的代码：创建一个更新方法，然后创建一个Watcher监听该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let updateComponent = () =&gt; &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)</span><br></pre></td></tr></table></figure></p>
<p>在 <code>new Watcher</code> 监听了 updateComponent 方法后，会立即执行 <code>updateComponent</code> 方法。在 <code>updateComponent</code> 方法中，我们之前提到 _render 方法最终返回一个编译过的 VNode 对象，即虚拟 DOM，这里我们就看看 _update 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  if (vm._isMounted) &#123;</span><br><span class="line">    callHook(vm, &apos;beforeUpdate&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  const prevEl = vm.$el</span><br><span class="line">  const prevVnode = vm._vnode</span><br><span class="line">  const prevActiveInstance = activeInstance</span><br><span class="line">  activeInstance = vm</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line"></span><br><span class="line">  if (!prevVnode) &#123;</span><br><span class="line">    // initial render</span><br><span class="line">    vm.$el = vm.__patch__(</span><br><span class="line">      vm.$el, vnode, hydrating, false /* removeOnly */,</span><br><span class="line">      vm.$options._parentElm,</span><br><span class="line">      vm.$options._refElm</span><br><span class="line">    )</span><br><span class="line">    vm.$options._parentElm = vm.$options._refElm = null</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // updates</span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  activeInstance = prevActiveInstance</span><br><span class="line">  // update __vue__ reference</span><br><span class="line">  if (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = null</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从注释可以看出，初次渲染会走到 <code>vm.__patch__</code> 方法中，这个方法就是比对虚拟 DOM ，局部更新 DOM 的方法，关于虚拟 DOM 和 VNode 节点，之后再聊。</p>
<h1 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h1><ul>
<li>通过 <code>renderMixin</code> 方法来定义一些渲染属性。</li>
<li><code>initRender</code> 定义了各类渲染选项，并且对一些属性进行监听。</li>
<li><code>$mount</code> 方法执行了 <code>mountComponent</code> 方法，监听<br><code>updateComponent</code> 方法并执行 <code>_update</code> 方法。</li>
<li><code>_update</code> 方法中执行 <code>__patch__</code> 方法渲染 VNode。</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这里简单理了理 <code>render</code> 渲染的代码流程，更深入的关于虚拟 DOM 的内容在下一篇中继续研究~<br>这里再提出几个问题，之后学习和解决：</p>
<ul>
<li>template 的具体编译细节</li>
<li>已知 data 数据监测，如何在改变数据后对改变界面的显示。</li>
<li>深入理解虚拟 DOM 的原理</li>
<li>学习全局 API 的源码</li>
<li>了解各类工具类</li>
<li>了解 AST 语法树是什么~</li>
</ul>
<p>计划3月底完成Vue源码的系统学习，之后转战vue-router、vuex、vuxt、 devtools、webpack、vue-loader，今年目标把Vue全家老小、亲戚朋友都学习一遍！加油！</p>
<h1 id="Vue-js学习系列"><a href="#Vue-js学习系列" class="headerlink" title="Vue.js学习系列"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>
<h1 id="Vue-js学习系列项目地址"><a href="#Vue-js学习系列项目地址" class="headerlink" title="Vue.js学习系列项目地址"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">https://github.com/violetjack/VueStudyDemos</a></p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>
<p>新浪微博： <a href="http://weibo.com/u/2640909603" target="_blank" rel="noopener">http://weibo.com/u/2640909603</a><br>掘金：<a href="https://gold.xitu.io/user/571d953d39b0570068145cd1" target="_blank" rel="noopener">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href="http://blog.csdn.net/violetjack0808" target="_blank" rel="noopener">http://blog.csdn.net/violetjack0808</a><br>简书： <a href="http://www.jianshu.com/users/54ae4af3a98d/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href="https://github.com/violetjack" target="_blank" rel="noopener">https://github.com/violetjack</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/02/19/Vue.js源码学习四 —— 渲染 Render 初始化过程学习/" data-id="cjdtq38d2000awfbtsorh2c33" class="article-share-link" data-share="baidu" data-title="Vue.js源码学习四 —— 渲染 Render 初始化过程学习">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/02/19/Vue.js源码学习四 —— 渲染 Render 初始化过程学习/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue.js源码学习三 —— 事件 Event 学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/17/Vue.js源码学习三 —— 事件 Event 学习/" class="article-date">
  <time datetime="2018-02-16T16:00:00.000Z" itemprop="datePublished">2018-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/17/Vue.js源码学习三 —— 事件 Event 学习/">Vue.js源码学习三 —— 事件 Event 学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>早上好！继续学习Vue源码~这次我们来学习 event 事件。</p>
</blockquote>
<h1 id="源码简析"><a href="#源码简析" class="headerlink" title="源码简析"></a>源码简析</h1><p>其实看了前两篇的同学已经知道源码怎么找了，这里再提一下。<br>先找到Vue核心源码index方法 <code>src/core/instance/index.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure></p>
<p>index方法中定义了一个Vue的构造函数执行 <code>_init</code> 方法初始化，然后执行了多个 <code>xxxMixin</code> 方法，这些方法是为Vue 的构造函数定义各类属性的。比如我们今天关注的事件，Vue的几个事件方法都是在 <code>eventsMixin</code> 中定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export function eventsMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$once = function (event: string, fn: Function): Component &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$emit = function (event: string): Component &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外要注意的是，<code>initMixin</code> 方法中定义了Vue的初始化方法 <code>_init</code>，该方法中对Vue各类属性进行了初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export function initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initProxy(vm)</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &apos;created&apos;)</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，在本篇博客中只需要关注 <code>initEvents</code> 和 <code>eventsMixin</code> 方法即可</p>
<h1 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h1><p>初始化过程很简单，清空数据，并初始化连接父级的事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/events.js</span><br><span class="line">export function initEvents (vm: Component) &#123;</span><br><span class="line">  vm._events = Object.create(null)</span><br><span class="line">  vm._hasHookEvent = false</span><br><span class="line">  // init parent attached events</span><br><span class="line">  const listeners = vm.$options._parentListeners</span><br><span class="line">  if (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我深入看了下 <code>updateComponentListeners</code> 方法，最终走到了 <code>src/core/vdom/helpers/update-listeners.js</code> 的 <code>updateListeners</code> 方法中，因为并没有传 <code>oldOn</code> 参数，所以我简化了下代码，简化代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// src/core/vdom/helpers/update-listeners.js</span><br><span class="line">export function updateListeners (</span><br><span class="line">  on: Object,</span><br><span class="line">  oldOn: Object,</span><br><span class="line">  add: Function,</span><br><span class="line">  remove: Function,</span><br><span class="line">  vm: Component</span><br><span class="line">) &#123;</span><br><span class="line">  let name, def, cur, old, event</span><br><span class="line">  for (name in on) &#123;</span><br><span class="line">    def = cur = on[name]</span><br><span class="line">    old = oldOn[name]</span><br><span class="line">    event = normalizeEvent(name)</span><br><span class="line"></span><br><span class="line">    if (isUndef(old)) &#123;</span><br><span class="line">      if (isUndef(cur.fns)) &#123;</span><br><span class="line">        cur = on[name] = createFnInvoker(cur)</span><br><span class="line">      &#125;</span><br><span class="line">      add(event.name, cur, event.once, event.capture, event.passive, event.params)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中这个add方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/events.js</span><br><span class="line">// target 临时引用vm，用完后即变为undefined</span><br><span class="line">var target;</span><br><span class="line"></span><br><span class="line">function add (event, fn, once) &#123;</span><br><span class="line">  if (once) &#123;</span><br><span class="line">    target.$once(event, fn);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    target.$on(event, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整理下来就是将父级的事件定义到当前vm中。</p>
<h1 id="on"><a href="#on" class="headerlink" title="$on"></a>$on</h1><blockquote>
<p>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</p>
</blockquote>
<p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/events.js</span><br><span class="line">Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  if (Array.isArray(event)) &#123;</span><br><span class="line">    for (let i = 0, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      this.$on(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">    // 通过使用标记为注册而不是散列查找的布尔标记来优化钩子 hook: 事件成本。</span><br><span class="line">    if (hookRE.test(event)) &#123;</span><br><span class="line">      vm._hasHookEvent = true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 event 是数组则遍历执行 $on 方法（2.2.0+ 中支持）；<br>否则 向 vm._events[event] 中传递回调函数 fn，这里既然 vm._events[event] 是一个数组，那么我猜想一个 event 可以执行多个回调函数咯？<br>如果是 event 字符串中有 <code>hook:</code>，修改 <code>vm._hasHookEvent</code> 的状态。如果 <code>_hasHookEvent</code> 为 true，那么在触发各类生命周期钩子的时候会触发如 <code>hook:created</code> 事件，这只是一种优化方式，与我们主题关系不大，具体请看代码~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">export function callHook (vm: Component, hook: string) &#123;</span><br><span class="line">  const handlers = vm.$options[hook]</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        handlers[i].call(vm)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `$&#123;hook&#125; hook`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&apos;hook:&apos; + hook)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="once"><a href="#once" class="headerlink" title="$once"></a>$once</h1><blockquote>
<p>监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。</p>
</blockquote>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/events.js</span><br><span class="line">Vue.prototype.$once = function (event: string, fn: Function): Component &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  function on () &#123;</span><br><span class="line">    vm.$off(event, on)</span><br><span class="line">    fn.apply(vm, arguments)</span><br><span class="line">  &#125;</span><br><span class="line">  on.fn = fn</span><br><span class="line">  vm.$on(event, on)</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个就简单了，定义一个 $on 事件监听，回调函数中使用 $off 方法取消事件监听，并执行回调函数。</p>
<h1 id="off"><a href="#off" class="headerlink" title="$off"></a>$off</h1><blockquote>
<p>移除自定义事件监听器。</p>
<ul>
<li>如果没有提供参数，则移除所有的事件监听器；</li>
<li>如果只提供了事件，则移除该事件所有的监听器；</li>
<li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li>
</ul>
</blockquote>
<p>代码如下，分析见注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/events.js</span><br><span class="line">Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  // 如果没有参数，关闭全部事件监听器</span><br><span class="line">  if (!arguments.length) &#123;</span><br><span class="line">    vm._events = Object.create(null)</span><br><span class="line">    return vm</span><br><span class="line">  &#125;</span><br><span class="line">  // 关闭数组中的事件监听器</span><br><span class="line">  if (Array.isArray(event)) &#123;</span><br><span class="line">    for (let i = 0, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      this.$off(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">    return vm</span><br><span class="line">  &#125;</span><br><span class="line">  // 具体某个事件监听</span><br><span class="line">  const cbs = vm._events[event]</span><br><span class="line">  // 没有这个监听事件，直接返回vm</span><br><span class="line">  if (!cbs) &#123;</span><br><span class="line">    return vm</span><br><span class="line">  &#125;</span><br><span class="line">  // 没有 fn，将事件监听器变为null，返回vm</span><br><span class="line">  if (!fn) &#123;</span><br><span class="line">    vm._events[event] = null</span><br><span class="line">    return vm</span><br><span class="line">  &#125;</span><br><span class="line">  // 有回调函数</span><br><span class="line">  if (fn) &#123;</span><br><span class="line">    // specific handler</span><br><span class="line">    let cb</span><br><span class="line">    let i = cbs.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      // cbs = vm._events[event] 是一个数组</span><br><span class="line">      cb = cbs[i]</span><br><span class="line">      if (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">        // 移除 fn 这个事件监听器</span><br><span class="line">        cbs.splice(i, 1)</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h1><blockquote>
<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
</blockquote>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/events.js</span><br><span class="line">Vue.prototype.$emit = function (event: string): Component &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  let cbs = vm._events[event]</span><br><span class="line">  if (cbs) &#123;</span><br><span class="line">    cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    for (let i = 0, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cbs[i].apply(vm, args)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `event handler for &quot;$&#123;event&#125;&quot;`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码分析：首先获取 vm._events[event] ，之前我们说过这玩意是个数组；如果有这个事件监听器，从第二个参数开始获取作为触发方法的传参 args，遍历事件监听器数组传参执行回调函数。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>就这么多啦~其实事件还是很简单的。明后天研究研究渲染这个难点！我们后天见！</p>
<h1 id="Vue-js学习系列"><a href="#Vue-js学习系列" class="headerlink" title="Vue.js学习系列"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>
<h1 id="Vue-js学习系列项目地址"><a href="#Vue-js学习系列项目地址" class="headerlink" title="Vue.js学习系列项目地址"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">https://github.com/violetjack/VueStudyDemos</a></p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>
<p>新浪微博： <a href="http://weibo.com/u/2640909603" target="_blank" rel="noopener">http://weibo.com/u/2640909603</a><br>掘金：<a href="https://gold.xitu.io/user/571d953d39b0570068145cd1" target="_blank" rel="noopener">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href="http://blog.csdn.net/violetjack0808" target="_blank" rel="noopener">http://blog.csdn.net/violetjack0808</a><br>简书： <a href="http://www.jianshu.com/users/54ae4af3a98d/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href="https://github.com/violetjack" target="_blank" rel="noopener">https://github.com/violetjack</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/02/17/Vue.js源码学习三 —— 事件 Event 学习/" data-id="cjdtq38d00008wfbtf20ziy74" class="article-share-link" data-share="baidu" data-title="Vue.js源码学习三 —— 事件 Event 学习">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/02/17/Vue.js源码学习三 —— 事件 Event 学习/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue.js源码学习二 —— 生命周期 LifeCycle 学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/16/Vue.js源码学习二 —— 生命周期 LifeCycle 学习/" class="article-date">
  <time datetime="2018-02-15T16:00:00.000Z" itemprop="datePublished">2018-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/16/Vue.js源码学习二 —— 生命周期 LifeCycle 学习/">Vue.js源码学习二 —— 生命周期 LifeCycle 学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>春节继续写博客~加油！</p>
</blockquote>
<p>这次来学习一下Vue的生命周期，看看生命周期是怎么回事。</p>
<h1 id="callHook"><a href="#callHook" class="headerlink" title="callHook"></a>callHook</h1><p>生命周期主要就是在源码某个时间点执行这个 <code>callHook</code> 方法来调用 <code>vm.$options</code> 的生命周期钩子方法（如果定义了生命周期钩子方法的话）。<br>我们来看看 callHook 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export function callHook (vm: Component, hook: string) &#123;</span><br><span class="line">  const handlers = vm.$options[hook] // 获取Vue选项中的生命周期钩子函数</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (let i = 0, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        handlers[i].call(vm) // 执行生命周期函数</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `$&#123;hook&#125; hook`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&apos;hook:&apos; + hook)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如触发 <code>mounted</code> 钩子的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;mounted&apos;)</span><br></pre></td></tr></table></figure></p>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>先上一张图看下Vue的生命周期，我们可以在相应的生命周期中定义一些事件。<br><img src="http://upload-images.jianshu.io/upload_images/1987062-4e8074eee45c60a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue生命周期"></p>
<h2 id="beforeCreate-amp-created"><a href="#beforeCreate-amp-created" class="headerlink" title="beforeCreate &amp; created"></a>beforeCreate &amp; created</h2><p>先看看这两个方法调用的时间。</p>
<blockquote>
<p><strong>beforeCreate</strong><br>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。<br><strong>created</strong><br>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
</blockquote>
<p>具体代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/init.js</span><br><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">  ……</span><br><span class="line">  initLifecycle(vm) // 初始化生命周期</span><br><span class="line">  initEvents(vm) // 初始化事件</span><br><span class="line">  initRender(vm) // 初始化渲染</span><br><span class="line">  callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">  initInjections(vm) // 初始化Inject</span><br><span class="line">  initState(vm) // 初始化数据</span><br><span class="line">  initProvide(vm) // 初始化Provide</span><br><span class="line">  callHook(vm, &apos;created&apos;)</span><br><span class="line">  ……</span><br><span class="line">  if (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el) // 如果有el属性，将内容挂载到el中去。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="beforeMount-amp-mounted"><a href="#beforeMount-amp-mounted" class="headerlink" title="beforeMount &amp; mounted"></a>beforeMount &amp; mounted</h2><blockquote>
<p><strong>beforeMount</strong><br>在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。<br><strong>mounted</strong><br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p>
</blockquote>
<p>贴出代码逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">// 挂载组件的方法</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  updateComponent = () =&gt; &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vm._watcher = new Watcher(vm, updateComponent, noop)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &apos;mounted&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这个 <code>mountComponent</code> 在哪里用了呢？就是在Vue的 $mount 方法中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/platforms/web/runtime/index.js</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后会在Vue初始化的时候，判断是否有 el，如果有则执行 $mount 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/init.js</span><br><span class="line">if (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el) // 如果有el属性，将内容挂载到el中去。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此生命周期逻辑应该是 beforeCreate - created - beforeMount -mounted</p>
<h2 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h2><blockquote>
<p><strong>beforeUpdate</strong><br>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。<br><strong>updated</strong><br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
</blockquote>
<p>找代码逻辑~ beforeUpdate 和 updated 在两个地方调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // 如果是已经挂载的，就触发beforeUpdate方法。</span><br><span class="line">    if (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &apos;beforeUpdate&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    // updated hook is called by the scheduler to ensure that children are</span><br><span class="line">    // updated in a parent&apos;s updated hook.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行 <code>_update</code> 方法的时候，如果 DOM 已经挂载了，则调用 <code>beforeUpdate</code> 方法。<br>在 _update 方法的最后作者也注视了调用 updated hook 的位置：<em><code>updated</code> 钩子由 <code>scheduler</code> 调用来确保子组件在一个父组件的 <code>update</code> 钩子中</em>。<br>我们找到 <code>scheduler</code>，发现有个 <code>callUpdateHooks</code> 方法，该方法遍历了 <code>watcher</code> 数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/core/observer/scheduler.js</span><br><span class="line">function callUpdatedHooks (queue) &#123;</span><br><span class="line">  let i = queue.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    const watcher = queue[i]</span><br><span class="line">    const vm = watcher.vm</span><br><span class="line">    if (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, &apos;updated&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>callUpdatedHooks</code> 在 <code>flushSchedulerQueue</code> 方法中调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 刷新队列并运行watcher</span><br><span class="line"> */</span><br><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line">  flushing = true</span><br><span class="line">  let watcher, id</span><br><span class="line">  queue.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line"></span><br><span class="line">  for (index = 0; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = null</span><br><span class="line">    watcher.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const activatedQueue = activatedChildren.slice()</span><br><span class="line">  const updatedQueue = queue.slice()</span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  // 调用组件的updated和activated生命周期</span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续找下去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">  const id = watcher.id</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true // 此参数用于判断watcher的ID是否存在</span><br><span class="line">    ……</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终在 <code>watcher.js</code> 找到 <code>update</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/observer/watcher.js</span><br><span class="line">update () &#123;</span><br><span class="line">  // lazy 懒加载</span><br><span class="line">  // sync 组件数据双向改变</span><br><span class="line">  if (this.lazy) &#123;</span><br><span class="line">    this.dirty = true</span><br><span class="line">  &#125; else if (this.sync) &#123;</span><br><span class="line">    this.run()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queueWatcher(this) // 排队watcher</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等于是队列执行完 Watcher 数组的 <code>update</code> 方法后调用了 <code>updated</code> 钩子函数。</p>
<h2 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h2><blockquote>
<p><strong>beforeDestroy</strong><br>实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。<br><strong>destroyed</strong><br>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>
</blockquote>
<p>看代码~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">// 销毁方法</span><br><span class="line">Vue.prototype.$destroy = function () &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  if (vm._isBeingDestroyed) &#123;</span><br><span class="line">    // 已经被销毁</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &apos;beforeDestroy&apos;)</span><br><span class="line">  vm._isBeingDestroyed = true</span><br><span class="line">  // 销毁过程</span><br><span class="line">  // remove self from parent</span><br><span class="line">  const parent = vm.$parent</span><br><span class="line">  if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">    remove(parent.$children, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  // teardown watchers</span><br><span class="line">  if (vm._watcher) &#123;</span><br><span class="line">    vm._watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">  let i = vm._watchers.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    vm._watchers[i].teardown()</span><br><span class="line">  &#125;</span><br><span class="line">  // remove reference from data ob</span><br><span class="line">  // frozen object may not have observer.</span><br><span class="line">  if (vm._data.__ob__) &#123;</span><br><span class="line">    vm._data.__ob__.vmCount--</span><br><span class="line">  &#125;</span><br><span class="line">  // call the last hook...</span><br><span class="line">  vm._isDestroyed = true</span><br><span class="line">  // invoke destroy hooks on current rendered tree</span><br><span class="line">  vm.__patch__(vm._vnode, null)</span><br><span class="line">  // 触发 destroyed 钩子</span><br><span class="line">  callHook(vm, &apos;destroyed&apos;)</span><br><span class="line">  // turn off all instance listeners.</span><br><span class="line">  vm.$off()</span><br><span class="line">  // remove __vue__ reference</span><br><span class="line">  if (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个销毁 Vue 实例的过程，将各种配置清空和移除。</p>
<h2 id="activated-amp-deactivated"><a href="#activated-amp-deactivated" class="headerlink" title="activated &amp; deactivated"></a>activated &amp; deactivated</h2><blockquote>
<p><strong>activated</strong><br>keep-alive 组件激活时调用。<br><strong>deactivated</strong><br>keep-alive 组件停用时调用。</p>
</blockquote>
<p>找到实现代码的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">export function activateChildComponent (vm: Component, direct?: boolean) &#123;</span><br><span class="line">  if (direct) &#123;</span><br><span class="line">    vm._directInactive = false</span><br><span class="line">    if (isInInactiveTree(vm)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (vm._directInactive) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._inactive || vm._inactive === null) &#123;</span><br><span class="line">    vm._inactive = false</span><br><span class="line">    for (let i = 0; i &lt; vm.$children.length; i++) &#123;</span><br><span class="line">      activateChildComponent(vm.$children[i])</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, &apos;activated&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deactivateChildComponent (vm: Component, direct?: boolean) &#123;</span><br><span class="line">  if (direct) &#123;</span><br><span class="line">    vm._directInactive = true</span><br><span class="line">    if (isInInactiveTree(vm)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!vm._inactive) &#123;</span><br><span class="line">    vm._inactive = true</span><br><span class="line">    for (let i = 0; i &lt; vm.$children.length; i++) &#123;</span><br><span class="line">      deactivateChildComponent(vm.$children[i])</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, &apos;deactivated&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上两个方法关键就是修改了 <code>vm._inactive</code> 的值，并且乡下遍历子组件，最后触发钩子方法。</p>
<h2 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h2><blockquote>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</blockquote>
<p>这是 2.5 以上版本有的一个钩子，用于处理错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// src/core/util/error.js</span><br><span class="line">export function handleError (err: Error, vm: any, info: string) &#123;</span><br><span class="line">  if (vm) &#123;</span><br><span class="line">    let cur = vm</span><br><span class="line">    // 向上冒泡遍历</span><br><span class="line">    while ((cur = cur.$parent)) &#123;</span><br><span class="line">      // 获取钩子函数</span><br><span class="line">      const hooks = cur.$options.errorCaptured</span><br><span class="line">      if (hooks) &#123;</span><br><span class="line">        for (let i = 0; i &lt; hooks.length; i++) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            // 执行 errorCaptured 钩子函数</span><br><span class="line">            const capture = hooks[i].call(cur, err, vm, info) === false</span><br><span class="line">            if (capture) return</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            globalHandleError(e, cur, &apos;errorCaptured hook&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  globalHandleError(err, vm, info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单，看代码即可~</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>除了生命周期钩子外，vue还提供了生命周期方法来直接调用。</p>
<h2 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h2><blockquote>
<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。<br>如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。<br>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options = this.$options</span><br><span class="line">  // resolve template/el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    // 获取template</span><br><span class="line">    let template = options.template</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template === &apos;string&apos;) &#123;</span><br><span class="line">        if (template.charAt(0) === &apos;#&apos;) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    // 编译template</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行 $mount 方法</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实很简单，先获取html代码，然后执行 <code>compileToFunctions</code> 方法执行编译过程（具体编译过程在学习Render的时候再说）。</p>
<h2 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate"></a>vm.$forceUpdate</h2><blockquote>
<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Vue.prototype.$forceUpdate = function () &#123;</span><br><span class="line">  var vm = this;</span><br><span class="line">  if (vm._watcher) &#123;</span><br><span class="line">    vm._watcher.update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是强制更新方法，执行了 <code>vm._watcher.update()</code> 方法。</p>
<h2 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h2><blockquote>
<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p>
</blockquote>
<p>找了找 <code>vm.$nextTick</code> 的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// src/core/instance/render.js</span><br><span class="line">Vue.prototype.$nextTick = function (fn: Function) &#123;</span><br><span class="line">  return nextTick(fn, this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>找到这个 <code>nextTick</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// src/core/util/next-tick.js</span><br><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &apos;nextTick&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体功能逻辑等学习完 <code>render</code> 再更新……</p>
<h2 id="vm-destroy"><a href="#vm-destroy" class="headerlink" title="vm.$destroy"></a>vm.$destroy</h2><blockquote>
<p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。<br>触发 beforeDestroy 和 destroyed 的钩子。</p>
</blockquote>
<p>关于$destroy 我们之前再说 destroyed 钩子的时候提到过了，这里就不再赘述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$destroy = function () &#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>首先说下过年博客计划，过年学习Vue各个模块的源码，并发布相应博客。另外还会发布一些前端知识的整理，便于下个月找工作~<br>然后，小结下自己看源码的一些小技巧：</p>
<ul>
<li>重点关注方法的执行、对象的实例化、对象属性的修改。</li>
<li>忽略开发版本提示逻辑、内部变量赋值。</li>
<li>有目标的看代码，根据主线目标进行源码学习。 </li>
</ul>
<p>OK，今天就这么多~ 明天去学习下Vue的事件源码！加油！明天见！</p>
<h1 id="Vue-js学习系列"><a href="#Vue-js学习系列" class="headerlink" title="Vue.js学习系列"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>
<h1 id="Vue-js学习系列项目地址"><a href="#Vue-js学习系列项目地址" class="headerlink" title="Vue.js学习系列项目地址"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">https://github.com/violetjack/VueStudyDemos</a></p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>
<p>新浪微博： <a href="http://weibo.com/u/2640909603" target="_blank" rel="noopener">http://weibo.com/u/2640909603</a><br>掘金：<a href="https://gold.xitu.io/user/571d953d39b0570068145cd1" target="_blank" rel="noopener">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href="http://blog.csdn.net/violetjack0808" target="_blank" rel="noopener">http://blog.csdn.net/violetjack0808</a><br>简书： <a href="http://www.jianshu.com/users/54ae4af3a98d/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href="https://github.com/violetjack" target="_blank" rel="noopener">https://github.com/violetjack</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/02/16/Vue.js源码学习二 —— 生命周期 LifeCycle 学习/" data-id="cjdtq38d10009wfbtsbsq6kpa" class="article-share-link" data-share="baidu" data-title="Vue.js源码学习二 —— 生命周期 LifeCycle 学习">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/02/16/Vue.js源码学习二 —— 生命周期 LifeCycle 学习/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-用hexo搭建博客笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/08/用hexo搭建博客笔记/" class="article-date">
  <time datetime="2018-02-08T01:41:25.543Z" itemprop="datePublished">2018-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/08/用hexo搭建博客笔记/">用hexo搭建博客笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>一直想有个自己的 Github.io 博客，感觉逼格能够上升一大截。</p>
</blockquote>
<p>很久之前就看到网上各种博客搭建的文章，但是从内心中总感觉好像是个很麻烦的事情。所以，一直没有动手去做。</p>
<p>昨天，趁着年前工作不忙，搭建了个博客，这里记录下过程。<br>其实，搭建hexo博客是非常简单的事情。</p>
<h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><p>Mac安装前提</p>
<ul>
<li>Xcode</li>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>这三个玩意儿对于我们开发者基本都是有的，没有装个就好。</p>
<h1 id="创建博客的过程"><a href="#创建博客的过程" class="headerlink" title="创建博客的过程"></a>创建博客的过程</h1><p>简单的几条 bash 命令就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init [文件夹名]</span><br><span class="line">$ cd [文件夹名]</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>以上步骤就已经安装完毕了。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 新建文章 layout为模板，title为文章名</span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line">// 启动本地服务器看hexo博客，地址为 `http://localhost:4000/`</span><br><span class="line">$ hexo server</span><br><span class="line">// 生成静态文件</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br><span class="line">// 部署建站</span><br><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br><span class="line">// 去除缓存文件</span><br><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>这几个命令就能应付常用博客发布了。</p>
<h1 id="创建Github-io"><a href="#创建Github-io" class="headerlink" title="创建Github.io"></a>创建Github.io</h1><p>在我的Github中创建 [github名].github.io这个项目，比如像我的 <a href="https://github.com/violetjack/violetjack.github.io" target="_blank" rel="noopener">violetjack.github.io</a> 。</p>
<h1 id="上传博客配置"><a href="#上传博客配置" class="headerlink" title="上传博客配置"></a>上传博客配置</h1><p>如果是通过git开源发布的，那么只需要在hexo项目根目录的 <code>_config.yml</code> 文件中添加如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: [github.io 仓库]</span><br><span class="line">  branch: [发布的分支]</span><br><span class="line">  message: [发布消息]</span><br></pre></td></tr></table></figure></p>
<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>hexo搭建的博客有很多的主题样式，可以在 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a> 查看选择。安装过程里面都会说。</p>
<p>比如我们安装 <code>Ada</code> 主题，首先用git克隆下仓库。这里，可以在hexo博客项目中去执行克隆行为，直接下载到hexo项目的themes目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada</span><br></pre></td></tr></table></figure></p>
<p>有些主题需要安装依赖库，在hexo项目根目录中安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-jade --save</span><br></pre></td></tr></table></figure></p>
<p>最后，修改hexo项目根目录下 <code>_config.yml</code> 中的 theme 选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: Ada</span><br></pre></td></tr></table></figure></p>
<p>这就完成了主题的修改。<br>主题的配置工作呢，在 <code>./themes/Ada/_config.yml</code> 中，具体修改看相应的 Github README。<br>其实如果有任何对主题不满意的地方可以直接去主题中修改，代码并不难，如果只是想改几个文本全局搜一下就能搜到了。</p>
<h1 id="添加关于页面"><a href="#添加关于页面" class="headerlink" title="添加关于页面"></a>添加关于页面</h1><p>样式中一般只有首页和文章两个标签可用，如果我们想添加其他标签，如 关于我，该怎么办呢？<br>创建 关于我 页面（添加 layout 选项，默认为post）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure></p>
<p>这样，项目中就多了 about 这个文件夹，修改其中的 md 文件即可编辑关于我页面。<br>然后将主题的配置 <code>./themes/Ada/_config.yml</code> 中的页面链接指向 about 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Header</span><br><span class="line">menu:</span><br><span class="line">  首页: /</span><br><span class="line">  文章: /archives</span><br><span class="line">  关于: /about</span><br></pre></td></tr></table></figure></p>
<p>好啦，这里就简单介绍下Hexo的用法~主要是记录下搭建的过程。整理下步骤：</p>
<ul>
<li>搭建环境</li>
<li>创建 Github.io，或者说GithubPage</li>
<li>使用hexo搭建博客</li>
<li>选择样式，添加页面、添加文章内容。</li>
<li>发布</li>
</ul>
<p>就这么多啦~快去选择一个喜欢的样式做一个自己的博客，提升逼格把~<br><strong>最后展示一下我的博客：</strong><a href="https://violetjack.github.io/">Vue实验室</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo中文网</a><br><a href="https://pages.github.com/" target="_blank" rel="noopener">github page</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/02/08/用hexo搭建博客笔记/" data-id="cjdtq38e0000mwfbt6jegrjcj" class="article-share-link" data-share="baidu" data-title="用hexo搭建博客笔记">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/02/08/用hexo搭建博客笔记/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue.js源码学习一 —— 数据选项 State 学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Vue.js源码学习一 —— 数据选项 State 学习/" class="article-date">
  <time datetime="2018-02-02T16:00:00.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Vue.js源码学习一 —— 数据选项 State 学习/">Vue.js源码学习一 —— 数据选项 State 学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>关于Vue源码学习的博客， <a href="http://hcysun.me/" target="_blank" rel="noopener">HcySunYang</a>的<a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Vue2.1.7源码学习</a>是我所见过讲的最清晰明了的博客了，非常适合想了解Vue源码的同学入手。本文是在看了这篇博客之后进一步的学习心得。<br>注意：本文所用Vue版本为 <code>2.5.13</code><br>PS：本文有点草率，之后会重写改进。</p>
</blockquote>
<h1 id="关于源码学习"><a href="#关于源码学习" class="headerlink" title="关于源码学习"></a>关于源码学习</h1><p>关于学习源码，我有话要说~<br>一开始我学习Vue的源码，是将 <a href="https://github.com/vuejs/vue/blob/dev/dist/vue.js" target="_blank" rel="noopener">Vue.js</a> 这个文件下载下来逐行去看……因为我听信了我同事说的“不过一万多行代码，实现也很简单，可以直接看。”结果可想而知，花了十几个小时看完代码，还通过打断点看流程，除了学习到一些新的js语法、一些优雅的代码写法、和对整个代码熟悉了之外，没啥其他收获。<br>其实，这是一个丢西瓜捡芝麻的行为，没有明确的目的笼统的看源码，最终迷失在各种细枝末节上了。<br>所以呢，我看源码的经验教训有如下几点：</p>
<ul>
<li>看代码，必须带着问题去找实现代码。</li>
<li>保持主线，不要纠结于细枝末节。永远记住你要解决什么问题。</li>
<li>找到一篇优质的博客、向前辈学习，让前辈带着你去学习事半功倍。</li>
<li>想看某编程语言的代码，必须要有扎实的语言基础。走路不稳就想跑，会摔得很惨~</li>
<li>学习之道，不能盲目。应该找到一种快速有效的方法，来有目的的实现学习目标。不要用战术上的勤奋来掩盖战略上的失误。看代码如此、看书学习亦如此~</li>
</ul>
<h1 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h1><p>这里我们来解决从哪里开始看代码的流程，重点是<strong>找到Vue构造函数的实现</strong>。<br>首先，找到 <code>package.json</code> 文件，从中找到编译命令 <code>&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;</code>，这里 <code>rollup</code> 是类似于 Webpack 的打包工具，打包文件在 <code>script/config.js</code> 中，找到该文件。找 <code>entry</code> 入口关键字（不会rollup，但配置方式和 Webpack 差不太多）。入口文件有好多配置，我们就找到会生成 <code>dist/vue.js</code> 的配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Runtime+compiler development build (Browser)</span><br><span class="line">&apos;web-full-dev&apos;: &#123;</span><br><span class="line">  entry: resolve(&apos;web/entry-runtime-with-compiler.js&apos;),</span><br><span class="line">  dest: resolve(&apos;dist/vue.js&apos;),</span><br><span class="line">  format: &apos;umd&apos;,</span><br><span class="line">  env: &apos;development&apos;,</span><br><span class="line">  alias: &#123; he: &apos;./entity-decoder&apos; &#125;,</span><br><span class="line">  banner</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>好，这里就找到了 <code>web/entry-runtime-with-compiler.js</code> 这个路径，完整路径应该是 <code>src/platform/web/entry-runtime-with-compiler.js</code>。在这个文件中我们找到一个Vue对象import进来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>
<p>我们顺着找到到 <code>src/platform/web/runtime/index.js</code> 这个文件，在文件中发现导入文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure></p>
<p>就顺着这个思路找，最终找到 <code>src/core/instance/index.js</code> 这个文件。<br>完整找到Vue实例入口文件的流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">script/config.js</span><br><span class="line">src/platform/web/entry-runtime-with-compiler.js</span><br><span class="line">src/platform/web/runtime/index.js</span><br><span class="line">src/core/index.js</span><br><span class="line">src/core/instance/index.js</span><br></pre></td></tr></table></figure></p>
<p>简单看看Vue构造函数的样子~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class="line">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class="line">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class="line">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class="line">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class="line">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue) // 初始化</span><br><span class="line">stateMixin(Vue) // 状态混合</span><br><span class="line">eventsMixin(Vue) // 事件混合</span><br><span class="line">lifecycleMixin(Vue) // 生命周期混合</span><br><span class="line">renderMixin(Vue) // 渲染混合</span><br><span class="line"></span><br><span class="line">export default Vue</span><br></pre></td></tr></table></figure></p>
<p>可以看到Vue的构造函数，里面只做了 <code>this._init(options)</code> 行为。这个 <code>_init</code> 方法在执行 <code>initMixin</code> 方法的时候定义了。找到同目录下的 <code>init.js</code> 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">export function initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class="line">  Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // a uid</span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    let startTag, endTag</span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class="line">      endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // a flag to avoid this being observed</span><br><span class="line">    vm._isVue = true</span><br><span class="line">    // merge options</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      // optimize internal component instantiation</span><br><span class="line">      // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      // internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 合并配置项</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      initProxy(vm) // 初始化代理</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vm._self = vm // 暴露对象自身</span><br><span class="line">    initLifecycle(vm) // 初始化生命周期</span><br><span class="line">    initEvents(vm) // 初始化事件：on,once,off,emit</span><br><span class="line">    initRender(vm) // 初始化渲染：涉及到Virtual DOM</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;) //  触发 beforeCreate 生命周期钩子</span><br><span class="line">    initInjections(vm) // 在初始化 data/props 前初始化Injections</span><br><span class="line">    initState(vm) // 初始化状态选项</span><br><span class="line">    initProvide(vm) // 在初始化 data/props 后初始化Provide</span><br><span class="line">    // 有关inject和provide请查阅 https://cn.vuejs.org/v2/api/#provide-inject</span><br><span class="line">    callHook(vm, &apos;created&apos;) // 触发 created 生命周期钩子</span><br><span class="line"></span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果Vue配置项中有el，直接挂在到DOM中</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抓住重点，<strong>我们是要来学习State的。</strong>从上面代码中可以找到initState方法的执行，这就是我们此行的目的——State数据选项。除此之外还有其他重要方法的初始化方式，这将会在之后的博客中继续讨论和学习。</p>
<h1 id="学习State"><a href="#学习State" class="headerlink" title="学习State"></a>学习State</h1><p>之前是简单提一下学习源码的方法论和如何开始学习Vue源码学习。并且找到了我们要学习的State所在，现在进入正题：</p>
<blockquote>
<p>了解Vue的数据选项的运行机制。</p>
</blockquote>
<p>在<a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Vue2.1.7源码学习</a>中，作者已经非常非常非常清晰明了的帮我们分析了data的实现。在此基础上开始好好学习其他数据选项的实现逻辑。</p>
<h2 id="通过data理解mvvm"><a href="#通过data理解mvvm" class="headerlink" title="通过data理解mvvm"></a>通过data理解mvvm</h2><p>这里我通过自己的思路再来整理下项目中data的实现。<br><strong>注：</strong>由于这一部分已经被各类源码解析博客讲烂了，而要把这部分讲清楚要大量篇幅。所以我就不贴代码了。还是那句话，抓重点！我们主要研究的是data之外的实现方式。关于data的实现和mvvm的逐步实现，<a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Vue2.1.7源码学习</a>中讲的非常清晰明了。</p>
<p><strong>以下是我整理的思路，有兴趣的同学可以顺着我的思路去看看。</strong></p>
<p>在 state.js 中找到 initState，并顺利找到 initData 函数。initData中主要做了以下几步操作：</p>
<ol>
<li>获取data数据，data数据通常是一个方法，执行方法返回data数据。所以说我们要将data写成函数方法的形式。</li>
<li>遍历data数据，判断是否有data与props的key同名，如果没有执行proxy方法，该方法用于将data中的数据同步到vm对象上，所以我们可以通过 <code>vm.name</code> 来修改和获取 data 中的 name 的值。</li>
<li>执行observe方法，监听data的变化。</li>
</ol>
<p>重点在 <code>observe</code> 方法，于是我们根据 import 关系找到 <code>src/core/observer/index.js</code> 文件。<code>observe</code> 方法通过传入的值最终返回一个Observer类的实例对象。<br>找到Observer类，在构造函数中为当前类创建Dep实例，然后判断数据，如果是数组，触发 observeArray 方法，遍历执行 observe 方法；如果是对象，触发walk方法。<br>找到walk方法，方法中遍历了数据对象，为对象每个属性执行 defineReactive 方法。<br><strong>找到 defineReactive 方法，该方法为 mvvm 数据变化检测的核心。</strong>为对象属性添加 set 和 get 方法。重点来了， vue 在 get 方法中执行 <code>dep.depend()</code> 方法，在 set 方法中执行 <code>dep.notify()</code> 方法。这个先不多讲，最后进行联结说明。<br>找到同目录下的 <code>dep.js</code> 文件，文件不长。定义了 Dep 类和<code>pushTarget</code>、<code>popTarget</code> 方法。在 Dep 类中有我们之前提到的 <code>depend</code> 和 <code>notify</code> 方法。看下两个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">  if (Dep.target) &#123;</span><br><span class="line">    Dep.target.addDep(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notify () &#123;</span><br><span class="line">  // stabilize the subscriber list first</span><br><span class="line">  const subs = this.subs.slice()</span><br><span class="line">  for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>depend</code> 方法中，Dep.target 就是一个 Watcher 实例，它的 <code>addDep</code> 方法最终会调用到 Dep 的 <code>addSubs</code> 方法。subs 是 Watcher 数组。即将当前 watcher 存到 Dep 的 subs 数组中。<br>在 <code>notify</code> 方法中，将 Watcher 数组 subs 遍历，执行他们的 <code>update</code> 方法。<code>update</code> 最终会去执行 <code>watcher</code> 的回调函数。<br>即在 get 方法中将 watcher 添加到 dep，在 set 方法中通过 dep 对 watcher 进行回调函数触发。<br>这里其实已经实现了数据监听，接着我们来看看 Watcher，其实 Watcher 就是Vue中 watch 选项的实现了。说到 watch 选项我们都知道它用来监听数据变化。Watcher 就是实现这个过程的玩意啦~<br>Watcher的构造函数最终调用了 <code>get</code> 方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">   pushTarget(this)</span><br><span class="line">   let value</span><br><span class="line">   const vm = this.vm</span><br><span class="line">   try &#123;</span><br><span class="line">     value = this.getter.call(vm, vm)</span><br><span class="line">   &#125; catch (e) &#123;</span><br><span class="line">     if (this.user) &#123;</span><br><span class="line">       handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       throw e</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">     // dependencies for deep watching</span><br><span class="line">     if (this.deep) &#123;</span><br><span class="line">       traverse(value)</span><br><span class="line">     &#125;</span><br><span class="line">     popTarget()</span><br><span class="line">     this.cleanupDeps()</span><br><span class="line">   &#125;</span><br><span class="line">   return value</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>get</code> 方法做了如下几步：</p>
<ol>
<li>将当前 Watcher 实例传递给 Dep 的 Dep.target。</li>
<li>执行 Watcher 所监测的数据的 <code>getter</code> 方法。</li>
<li>最终，将 <code>Dep.target</code> 恢复到上一个值，并且将当前 Watcher 从 Dep 的 subs 中去除。</li>
</ol>
<p>其中要注意的是，在第二步中数据的 <code>getter</code> 方法会执行到 <code>dep.depend()</code> 方法，<code>depend</code> 方法将当前 watcher 加入到 subs 中。至于步骤一和三还不太理解。挖个坑先~<br>这样 watcher 就监测上数据了。那怎么使用呢？当然是数据变化时使用咯。当监测的数据变化时，执行数据 setter 方法，然后执行 dep 的 <code>notify</code> 方法。由于我们之前已经将 watcher 都收集到 dep 的 subs 中，<code>notify</code> 方法遍历执行 watcher 的 <code>update</code> 方法，<code>update</code> 方法最终遍历执行回调函数。</p>
<ol>
<li>执行 <code>observe</code> 方法，创建 Observer 执行 <code>walk</code> 为对象数据添加setter 和 getter</li>
<li>在添加 setter 和 getter 时，创建 Dep，在 getter 方法中执行 <code>dep.depend()</code> 收集 watcher，在 setter 方法中执行 <code>dep.notify()</code> 方法，最终遍历执行 watcher 数组的回调函数。</li>
<li>Dep 类似于 Watcher 和 Observer 的中间件。</li>
<li>Watcher 用于监听变化，并执行回调函数。</li>
<li>当 Watcher 实例创建时，Watcher 实例会将自身传递给 Dep.target</li>
<li>Watcher 调用监测数据的 <code>getter</code>方法触发 <code>dep.depend()</code></li>
<li><code>dep.depend()</code>方法将当前 Watcher（Dep.target）传递给Dep的subs（watcher数组）中。</li>
<li>当被监测的数据内容发生改变时，执行 <code>setter</code> 方法，触发 <code>dep.notify()</code> 方法，遍历 Dep 中的 subs（watcher数组），执行 Watcher 的回调函数。</li>
</ol>
<p>嗯……就是这样~之后把挖的坑填上！</p>
<h2 id="watch实现"><a href="#watch实现" class="headerlink" title="watch实现"></a>watch实现</h2><p>说完了 Data 的监听流程，说说 watch 应该就不难啦~<br>找到 <code>src/core/instance/state.js</code> 的 <code>initWatch</code> 函数，该方法用来遍历 Vue 实例中的 watch 项，最终所有 watch 都会执行 <code>createWatcher</code> 方法。<br>继续看 <code>createWatcher</code> 方法，这个方法也很简单，最终返回 <code>vm.$watch(keyOrFn, handler, options)</code>。我们继续往下找~<br>在 <code>stateMixin</code> 方法中找到了定义 Vue 的 $watch 方法属性。来看看怎么实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = function (</span><br><span class="line">  expOrFn: string | Function,</span><br><span class="line">  cb: any,</span><br><span class="line">  options?: Object</span><br><span class="line">): Function &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  if (isPlainObject(cb)) &#123;</span><br><span class="line">    return createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  options.user = true</span><br><span class="line">  const watcher = new Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  if (options.immediate) &#123;</span><br><span class="line">    cb.call(vm, watcher.value)</span><br><span class="line">  &#125;</span><br><span class="line">  return function unwatchFn () &#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果回调函数 cb 是一个对象，那么返回并执行 <code>createWatcher</code> 函数，最终还是会走到 $watch 方法中。<br>否则，创建一个 Watcher 实例，当这个实例创建后，目标数据有任何变化 watch 选项中都能监听到了。如果是有 immediate 参数，那么立即执行一次Watcher的回调函数。最后返回一个解除监听的方法，执行了 Watcher 的 teardown 方法。<br>那么问题来了，为什么watch选项监听数据的方法中参数是如下写法呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  a: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以找到 <code>src/core/instance/observer/watcher.js</code> 中找到 <code>run</code> 方法。可以看到 <code>this.cb.call(this.vm, value, oldValue)</code> 这里的 cb 回调函数传递的参数就是 value 和 oldValue。<br>这里说个基础知识，函数使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener"> call 方法</a>执行，第一个参数是方法的this值，之后才是真正的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value = this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !== this.value ||</span><br><span class="line">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class="line">        // when the value is the same, because the value may</span><br><span class="line">        // have mutated.</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        // set new value</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        this.value = value</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>小结：watch 选项其实就是为指定数据创建 Watcher 实例，接收回调函数的过程。</strong></p>
<h2 id="props实现"><a href="#props实现" class="headerlink" title="props实现"></a>props实现</h2><p>接下来我们看看props，官网对props的定义如下：</p>
<blockquote>
<p>props 可以是数组或对象，用于接收来自父组件的数据。</p>
</blockquote>
<p>找到 <code>initProps</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function initProps (vm: Component, propsOptions: Object) &#123;</span><br><span class="line">  const propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  const props = vm._props = &#123;&#125;</span><br><span class="line">  // cache prop keys so that future props updates can iterate using Array</span><br><span class="line">  // instead of dynamic object key enumeration.</span><br><span class="line">  const keys = vm.$options._propKeys = []</span><br><span class="line">  const isRoot = !vm.$parent</span><br><span class="line">  // root instance props should be converted</span><br><span class="line">  observerState.shouldConvert = isRoot</span><br><span class="line">  for (const key in propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    const value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      const hyphenatedKey = hyphenate(key)</span><br><span class="line">      if (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `&quot;$&#123;hyphenatedKey&#125;&quot; is a reserved attribute and cannot be used as component prop.`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            `Avoid mutating a prop directly since the value will be ` +</span><br><span class="line">            `overwritten whenever the parent component re-renders. ` +</span><br><span class="line">            `Instead, use a data or computed property based on the prop&apos;s ` +</span><br><span class="line">            `value. Prop being mutated: &quot;$&#123;key&#125;&quot;`,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!(key in vm)) &#123;</span><br><span class="line">      proxy(vm, `_props`, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  observerState.shouldConvert = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，props 和 data 类似。在 <code>initProps</code> 中无非做了两步：<code>defineReactive</code> 和 <code>proxy</code>，这两个方法我们在提到 data 的时候讲过了。<code>defineReactive</code> 为数据设置 setter、getter，<code>proxy</code> 方法将 <code>props</code> 中的属性映射到 Vue 实例 vm 上，便于我们可以用 <code>vm.myProps</code> 来获取数据。<br>至此，我有个疑问：data与props有何不同呢？<br>data使用的是observe方法，创建一个Observer对象，Observer对象最终是执行了defineReactive方法。而props是遍历选项属性，执行defineReactive方法。中间可能就多了个Observer对象，那么这个Observer对象的作用到底在哪呢？经过实践props属性改变后界面也会改变。说明mvvm对props也是成立的。<br>另外，data和props有个不同的地方就是props是不建议改变的。详见<a href="https://cn.vuejs.org/v2/guide/components.html#单向数据流" target="_blank" rel="noopener">单向数据流</a><br>小结：逻辑和data类似，都是监听数据。不同之处呢……再研究研究~</p>
<h2 id="computed实现"><a href="#computed实现" class="headerlink" title="computed实现"></a>computed实现</h2><p>再来说说computed，找到初始化computed方法 <code>src/core/instance/state.js</code> 中的 <code>initComputed</code> 方法，去除非关键代码后看到其实主要有俩个行为，为 computed 属性创建 Watcher，然后执行 <code>defineComputed</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function initComputed (vm: Component, computed: Object) &#123;</span><br><span class="line">  ...</span><br><span class="line">  for (const key in computed) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (!isSSR) &#123;</span><br><span class="line">      watchers[key] = new Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!(key in vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>defineComputed 做了两步行为：一是定义 sharedPropertyDefinition 的 getter 和 setter，二是将 sharedPropertyDefinition 的属性传给vm，即 <code>Object.defineProperty(target, key, sharedPropertyDefinition)</code>。自此，我们可以通过 <code>vm.computedValue</code> 来获取计算属性结果了。<br><strong>小结：computed其实也就是一个数据监听行为，与data和props不同之处就是在get函数中需要进行逻辑计算处理。</strong></p>
<h2 id="methods实现"><a href="#methods实现" class="headerlink" title="methods实现"></a>methods实现</h2><p>继续在 <code>state.js</code> 中看到 <code>initMethods</code> 方法。顾名思义，这是初始化methods的方法。实现很简单，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function initMethods (vm: Component, methods: Object) &#123;</span><br><span class="line">  const props = vm.$options.props</span><br><span class="line">  for (const key in methods) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      if (methods[key] == null) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; has an undefined value in the component definition. ` +</span><br><span class="line">          `Did you reference the function correctly?`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      if (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; has already been defined as a prop.`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      if ((key in vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; conflicts with an existing Vue instance method. ` +</span><br><span class="line">          `Avoid defining component methods that start with _ or $.`</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点在最后一句。前面都排除重名和空值错误的，最后将 methods 中的方法传给 vm，方法内容如果为空则方法什么都不做。否则调用 <code>bind</code> 方法执行该函数。<br>找到这个 <code>bind</code> 方法，位置在 <code>src/shared/util.js</code> 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export function bind (fn: Function, ctx: Object): Function &#123;</span><br><span class="line">  function boundFn (a) &#123;</span><br><span class="line">    const l: number = arguments.length</span><br><span class="line">    return l</span><br><span class="line">      ? l &gt; 1</span><br><span class="line">        ? fn.apply(ctx, arguments)</span><br><span class="line">        : fn.call(ctx, a)</span><br><span class="line">      : fn.call(ctx)</span><br><span class="line">  &#125;</span><br><span class="line">  // record original fn length</span><br><span class="line">  boundFn._length = fn.length</span><br><span class="line">  return boundFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法返回一个执行 <code>methods</code> 中函数的方法（这种方法的执行方式比较快）。<br><strong>小结：将methods的方法用bind函数优化执行过程。然后将methods中的各个方法传给Vue实例对象。</strong></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文纯属个人理解，如有任何问题，请及时指出，不胜感激~<br>最后提出一个看源码的小心得：</p>
<blockquote>
<p>我发现……看源码、跟流程，尽量将注意力集中在<strong>方法的执行</strong>和<strong>类的实例化</strong>行为上。对于变量的获取和赋值、测试环境警报提示，简略看下就行，避免逐行阅读代码拉低效率。</p>
</blockquote>
<p>至此，Vue中的几个数据选项都学习了一遍了。关键在于理解mvvm的过程。data 理解之后，props、watch、computed 都好理解了。methods 和 mvvm 无关……<br>通过四个早上的时间把文章写出来了~对 Vue 的理解深刻了一些，但是还是能感觉到有很多未知的知识点等着我去发掘。加油吧！今年专注于 Vue 前端学习，把 Vue 给弄懂！</p>
<h1 id="Vue-js学习系列"><a href="#Vue-js学习系列" class="headerlink" title="Vue.js学习系列"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>
<h1 id="Vue-js学习系列项目地址"><a href="#Vue-js学习系列项目地址" class="headerlink" title="Vue.js学习系列项目地址"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">https://github.com/violetjack/VueStudyDemos</a></p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>
<p>新浪微博： <a href="http://weibo.com/u/2640909603" target="_blank" rel="noopener">http://weibo.com/u/2640909603</a><br>掘金：<a href="https://gold.xitu.io/user/571d953d39b0570068145cd1" target="_blank" rel="noopener">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href="http://blog.csdn.net/violetjack0808" target="_blank" rel="noopener">http://blog.csdn.net/violetjack0808</a><br>简书： <a href="http://www.jianshu.com/users/54ae4af3a98d/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href="https://github.com/violetjack" target="_blank" rel="noopener">https://github.com/violetjack</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/02/03/Vue.js源码学习一 —— 数据选项 State 学习/" data-id="cjdtq38cz0007wfbt2ihh8igh" class="article-share-link" data-share="baidu" data-title="Vue.js源码学习一 —— 数据选项 State 学习">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/02/03/Vue.js源码学习一 —— 数据选项 State 学习/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue学习系列倡议书" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/29/Vue学习系列倡议书/" class="article-date">
  <time datetime="2018-01-28T16:00:00.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/29/Vue学习系列倡议书/">Vue学习系列倡议书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我想通过社区的力量把《Vue学习系列》做到最优质的Vue系列博客</p>
</blockquote>
<h1 id="解决学习痛点"><a href="#解决学习痛点" class="headerlink" title="解决学习痛点"></a>解决学习痛点</h1><p>学习前端的同学都知道，前端有一大痛点就是知识点分散，学习的东西多。<br>就像我学习Vue，一拿到手就告诉我有个全家桶要学习。虽然一个一个学习下来了，但是过程是比较漫长的。而且如果是刚入门前端世界，会发现还没开始写代码各种配置都能玩好几天。Webpack打包、ESLint代码检查、Babel语法转译等等……<br>写本系列博客的本意是想将学习Vue的内容用博客的形式写出来，加深对知识点的理解。同时也希望能够帮助到和我有同样需求的朋友。<br>不过，就在昨天晚上我突然多了一个想法。<strong>我想把《Vue学习系列》做到最优质的Vue系列博客。</strong>通过我惯用的 <strong>资料索引+个人理解+Demo</strong> 的方式将Vue前端世界的所有都讲清楚、讲明白。让想学习前端的同学能够快速度过学习的迷茫期。通过本系列博客，快速入门Vue前端世界。<br><strong>打一个比方就是：官方文档是满汉全席，那么本系列博客就是肯德基、麦当劳，提高效率，拿来就用！</strong></p>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p><strong>通过一篇博客和一个演示项目快速学会Vue某个功能的常规使用方法。</strong><br>本系列博客定位是刚入门学习Vue的同学~相比于看官方文档，通过本系列博客有几个优点：</p>
<ul>
<li><strong>常用功能</strong> —— 正如二八原则一样，100%的学习内容中只有20%是常用而又必要的，我们先把20%掌握开始上手，其他80%按需学习。</li>
<li><strong>个人理解</strong> —— 尽量用容易理解的语言对技术点进行描述，最好能让没有学过前端的人都能理解是怎么回事。</li>
<li><strong>实例项目</strong> —— 每篇博客一个简单的小项目，包含了博客中提到的所有功能的实现（其实作者是边撸博客边写demo的，确保博客内容是可执行的）。博客和demo配合味道更佳哦~</li>
<li><strong>踩坑提醒</strong> —— 前端项目中总是会有一些奇奇怪怪的坑，如果作者踩过了，我会尽量提出。避免其他同学浪费时间精力去过这些无谓的坑。</li>
</ul>
<p>在入门系列发布后，会继续发布高级系列、源码解析系列。让我们一起学习共同进步。</p>
<h1 id="倡议"><a href="#倡议" class="headerlink" title="倡议"></a>倡议</h1><blockquote>
<p><a href="https://github.com/violetjack/VueStudyDemos/tree/master/Blogs" target="_blank" rel="noopener">《Vue学习系列》博客</a>的文本和Demo都将发布在Github上，并且博客内容将在<a href="https://www.jianshu.com/c/edec9ac6d9a7" target="_blank" rel="noopener">简书</a>上首发和更新。<br>如果对本系列课程有任何建议、想法、评论。可以在简书下留言，或者在VueStudyDemos项目中提交 issue 和 PR，希望通过大家的力量将本系列课程做好，帮助到更多人。</p>
</blockquote>
<p>到我写本文的时候，Vue学习系列的demo项目<a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">VueStudyDemos</a>已有173颗star了。感谢大家的支持，希望本系列博客真的可以帮助到大家。之后还会继续产出Vue相关的博客。</p>
<h1 id="Vue-js学习系列"><a href="#Vue-js学习系列" class="headerlink" title="Vue.js学习系列"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>
<p><a href="http://www.jianshu.com/p/8013d8d37bd0" target="_blank" rel="noopener">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href="http://www.jianshu.com/p/d6f7e11f18af" target="_blank" rel="noopener">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href="http://www.jianshu.com/p/8e5fb763c3d7" target="_blank" rel="noopener">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href="http://www.jianshu.com/p/aef34acd111f" target="_blank" rel="noopener">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href="http://www.jianshu.com/p/efb6fbed6fac" target="_blank" rel="noopener">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href="http://www.jianshu.com/p/073d25a3bba0" target="_blank" rel="noopener">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href="https://www.jianshu.com/p/ba7466d7101a" target="_blank" rel="noopener">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href="https://www.jianshu.com/p/15028f91226e" target="_blank" rel="noopener">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>
<h1 id="Vue-js学习系列项目地址"><a href="#Vue-js学习系列项目地址" class="headerlink" title="Vue.js学习系列项目地址"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">https://github.com/violetjack/VueStudyDemos</a></p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>
<p>新浪微博： <a href="http://weibo.com/u/2640909603" target="_blank" rel="noopener">http://weibo.com/u/2640909603</a><br>掘金：<a href="https://gold.xitu.io/user/571d953d39b0570068145cd1" target="_blank" rel="noopener">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href="http://blog.csdn.net/violetjack0808" target="_blank" rel="noopener">http://blog.csdn.net/violetjack0808</a><br>简书： <a href="http://www.jianshu.com/users/54ae4af3a98d/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href="https://github.com/violetjack" target="_blank" rel="noopener">https://github.com/violetjack</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/01/29/Vue学习系列倡议书/" data-id="cjdtq38dn000bwfbt2mb26a4c" class="article-share-link" data-share="baidu" data-title="Vue学习系列倡议书">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/01/29/Vue学习系列倡议书/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue.js学习系列七 —— Vue服务器渲染Nuxt学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/26/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习/" class="article-date">
  <time datetime="2018-01-25T16:00:00.000Z" itemprop="datePublished">2018-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/26/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习/">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我又回来啦~这次我们来学习Vue的服务器渲染SSR。</p>
</blockquote>
<p>关于SSR的文章网上很多，一开始看得我云里雾里。然后去<a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">Vue.js 服务器渲染指南</a>和<a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">nuxt官网</a>看了看，发现文章大多都是搬运官网的内容，真正讲的清晰明了的很少。所以想写篇文章学习下SSR，希望能够帮助大家快速理解Vue SSR。</p>
<h1 id="什么是SSR？"><a href="#什么是SSR？" class="headerlink" title="什么是SSR？"></a>什么是SSR？</h1><p>SSR，即服务器渲染，就是在服务器端将对Vue页面进行渲染生成html文件，将html页面传给浏览器。<br>优点：</p>
<ul>
<li>SEO 不同于SPA的HTML只有一个无实际内容的HTML和一个app.js，SSR生成的HTML是有内容的，这让搜索引擎能够索引到页面内容。</li>
<li>更快内容到达时间 传统的SPA应用是将bundle.js从服务器获取，然后在客户端解析并挂载到dom。而SSR直接将HTML字符串传递给浏览器。大大加快了首屏加载时间。</li>
</ul>
<p>可以从下面两张图来看，第一张图是SSR生成的HTML页面，第二种是传统SPA生成的HTML页面。<br><img src="http://upload-images.jianshu.io/upload_images/1987062-744de5a6489440da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSR"><br><img src="http://upload-images.jianshu.io/upload_images/1987062-1b940fb15ba7fbd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SPA"></p>
<h1 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h1><p>我看了官方 SSR 的介绍，也看了 Nuxt.js 的文档。本质上来说 SSR 是node后端的操作行为，作为只想好好写前端代码的我，不想太折腾。而 Nuxt.js 非常完美地整合了 SSR 的功能。让我们可以开箱即用~官方也推荐使用 Nuxt.js 来搭建 SSR 项目。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我觉得  Nuxt.js  相比自己写 SSR 有几点好处。</p>
<ul>
<li>无需配置Webpack：我一开始还在找Webpack配置呢，看了文档知道nuxt都帮我们封装好了。如需修改Webpack配置只需修改nuxt.config.js 文件。</li>
<li>无需node知识：只要你会写vue前端，你就可以写出SSR。无需知道SSR和node、express的配置方法（不过现在的前端多少都会点node知识~）。</li>
<li>整合了vue全家桶，直接可用。方便程度不亚于 <code>vue-cli</code>：安装Nuxt——写组件——编译并启动服务———看效果。就这么简单。</li>
<li>配置简单，文档友好：认真看下 Nuxt.js 文档就会发现涵盖的内容并不多，而功能很全，非常适合入手。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装方法<a href="https://zh.nuxtjs.org/guide/installation" target="_blank" rel="noopener">在此</a>。很简单，生成模板，然后npm安装依赖，最后再运行。<br>简单搬运下步骤吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// vue-cli 创建nuxt模板项目</span><br><span class="line">$ vue init nuxt-community/starter-template &lt;project-name&gt;</span><br><span class="line">// 安装依赖项</span><br><span class="line">$ cd &lt;project-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line">// 编译并启动服务</span><br><span class="line">$ npm run dev</span><br><span class="line">// 打开 http://localhost:3000</span><br></pre></td></tr></table></figure></p>
<p><strong>安装遇到的问题：</strong><br>由于 Nuxt.js 中使用了 <code>async...await</code> 语法，而低版本的 node 不支持这个语法，所以必须升级 node 到 <strong>7.0</strong> 版本之上~<br>然后建议不要使用cnpm，我用cnpm安装运行老报错，感觉有坑。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>Nuxt.js 花了很大的篇幅讲它的目录结构，其实了解了目录结构就了解了 Nuxt.js 的大概。Nuxt.js 帮我们配置好了所有东西，我们只需要按照它的要求在相应目录下创建文件写代码即可。</p>
<ul>
<li>assets 需要编译的资源文件，如 JavaScript、SASS、LESS 等。</li>
<li>static 不需要编译的静态资源文件，如图片资源。</li>
<li>components 顾名思义，存放 <code>*.vue</code> 组件的地方。常规 vue 组件写法。</li>
<li>layouts 布局目录，设置布局的地方，其中 <code>&lt;nuxt/&gt;</code> 标签是我们写的页面内容。可用作添加导航栏、底部栏等截面。</li>
<li>middleware 中间件目录，所谓中间件，就是在页面与页面跳转中执行的函数方法。如页面跳转时验证用户信息操作。</li>
<li>pages 页面目录。重点来了~这就是我们存放展示页面的地方。该目录下的文件会转换成相应的路由路径供浏览器访问。另外呢，该目录下的 <code>*.vue</code> 页面文件中  Nuxt.js 提供了一些特殊的方法用于处理服务器渲染中的事件。具体关于路由和特殊方法列举在下面了。<ul>
<li><a href="https://zh.nuxtjs.org/guide/routing" target="_blank" rel="noopener">pages 路由</a></li>
<li><a href="https://zh.nuxtjs.org/guide/views#页面" target="_blank" rel="noopener">页面组件</a>的简单介绍，具体特殊配置项的用法请查阅<a href="https://zh.nuxtjs.org/api" target="_blank" rel="noopener">API</a>。</li>
</ul>
</li>
<li>plugins 插件目录，像 mint-ui 这种第三方插件就放在这里啦~具体用法<a href="https://zh.nuxtjs.org/guide/plugins" target="_blank" rel="noopener">看这里</a>。</li>
<li>store vuex 状态管理器目录，如果该目录是空的， Nuxt.js 将不启用 vuex。当我们在该文件夹下创建 index.js 文件后即可使用 vuex 状态管理器。用法<a href="https://zh.nuxtjs.org/guide/vuex-store" target="_blank" rel="noopener">在此</a>！</li>
<li>nuxt.config.js 该文件是 Nuxt.js 的唯一配置项，之前提过 Nuxt.js 将 Webpack 等一众配置都封装好了，所以如果需要特殊配置，只需要修改该文件来覆盖默认配置即可。具体配置参数请查阅<a href="https://zh.nuxtjs.org/api" target="_blank" rel="noopener">API</a>。</li>
<li>package.json 不解释……</li>
</ul>
<h1 id="Demo演示"><a href="#Demo演示" class="headerlink" title="Demo演示"></a>Demo演示</h1><p>好消息，<a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">VueStudyDemos</a>又更新啦！欢迎Star~<a href="https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo" target="_blank" rel="noopener">本文Demo</a>已收入到VueStudyDemos中。<br>下面我们来简单实现下各文件夹所提到的功能。</p>
<h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>我在 assets 文件夹下添加了 font-awesome 字体库，在 static 文件夹中放了张 Vue 的 logo 图片。然后对资源进行调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-address-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;img src=&quot;~/static/logo.png&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里需要将 font-awesome 的 css 变为全局 css，避免每个用到的页面中都 import 字体库的css。所以我们在 nuxt.config.js 中添加如下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  css: [</span><br><span class="line">    &apos;~/assets/font-awesome/css/font-awesome.min.css&apos;</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件定义"><a href="#组件定义" class="headerlink" title="组件定义"></a>组件定义</h2><p>组件存放在 components 文件夹下，这个我们讲目录的时候提到过。组件的用法和常用 vue 组件用法一致。<br>定义组件 Avatar，然后在 Page 页面中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;avatar/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import avatar from &apos;~/components/Avatar&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    ...</span><br><span class="line">    components: &#123;</span><br><span class="line">        avatar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在 layouts 目录中，default 是默认布局。我们可以修改默认布局也可以新建布局来使用。<br>在布局文件中 <code>&lt;/nuxt&gt;</code> 标签是我们要服务器渲染的区域。<br>下面我们来创建个布局玩玩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// layouts/page.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;mt-header fixed title=&quot;标题2&quot;&gt;&lt;/mt-header&gt;</span><br><span class="line">    &lt;nuxt/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后我们来使用布局，在 pages 页面中配置 layout 选项（如果不配置默认就是 <code>default</code>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    ...</span><br><span class="line">    layout: &apos;page&apos;  // 默认是 &apos;default&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>所谓中间件，就是在两个页面跳转之间执行的行为。比如我定义一个中间件 add.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function (&#123; store &#125;) &#123;</span><br><span class="line">    store.commit(&apos;increment&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在 nuxt.config.js 中进行配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: &apos;add&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在每次页面跳转的时候都会执行一次中间件方法了。当然，也可以单独定义某个页面的中间件，具体看官网啦~</p>
<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p>页面，就是在pages目录下的 <code>*.vue</code> 文件，Nuxt.js 将目录结构配置为 vue-router 路由系统，所以我们可以直接通过文件名来访问到相应页面（先不提特殊路由）。<br>比如 <code>pages/app.vue</code> 文件就可以通过 <code>http://localhost:3000/app</code> 来进行访问。<br>注意：页面组件写法与常用 Vue 组件写法相同，但 Nuxt.js 还提供了一些特殊配置项来配置服务器渲染过程中的行为。具体有啥配置请看<a href="https://zh.nuxtjs.org/guide/views#页面" target="_blank" rel="noopener">页面文档</a>。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由就是使 pages 目录能够直接访问的原因。Nuxt.js 非常巧妙地使用目录结构和文件名称将 vue-router 的各种用法都涵盖进去了。如动态路由、嵌套路由等。具体可参考<a href="https://zh.nuxtjs.org/guide/routing" target="_blank" rel="noopener">文档</a>。也可以看看demo的 <a href="https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo/pages" target="_blank" rel="noopener">pages</a> 目录。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>对于前端项目，插件的使用当然是必不可少的。官网上对这方面讲的很清楚。我贴一下 demo 中的用法。这里用的是 mint-ui 库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// plugins/mint-ui.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import MintUI from &apos;mint-ui&apos;</span><br><span class="line">import &apos;mint-ui/lib/style.css&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(MintUI)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// nuxt.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    vendor: [&apos;mint-ui&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &apos;~plugins/mint-ui&apos;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用第三方库 mint-ui 啦！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;mt-navbar v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;mt-tab-item id=&quot;1&quot;&gt;选项一&lt;/mt-tab-item&gt;</span><br><span class="line">        &lt;mt-tab-item id=&quot;2&quot;&gt;选项二&lt;/mt-tab-item&gt;</span><br><span class="line">        &lt;mt-tab-item id=&quot;3&quot;&gt;选项三&lt;/mt-tab-item&gt;</span><br><span class="line">    &lt;/mt-navbar&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- tab-container --&gt;</span><br><span class="line">    &lt;mt-tab-container v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;mt-tab-container-item id=&quot;1&quot;&gt;</span><br><span class="line">            &lt;mt-cell v-for=&quot;n in 10&quot; :key=&quot;n&quot; :title=&quot;&apos;内容 &apos; + n&quot; /&gt;</span><br><span class="line">        &lt;/mt-tab-container-item&gt;</span><br><span class="line">        &lt;mt-tab-container-item id=&quot;2&quot;&gt;</span><br><span class="line">            &lt;mt-cell v-for=&quot;n in 4&quot; :key=&quot;n&quot; :title=&quot;&apos;测试 &apos; + n&quot; /&gt;</span><br><span class="line">        &lt;/mt-tab-container-item&gt;</span><br><span class="line">        &lt;mt-tab-container-item id=&quot;3&quot;&gt;</span><br><span class="line">            &lt;mt-cell v-for=&quot;n in 6&quot; :key=&quot;n&quot; :title=&quot;&apos;选项 &apos; + n&quot; /&gt;</span><br><span class="line">        &lt;/mt-tab-container-item&gt;</span><br><span class="line">    &lt;/mt-tab-container&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>对于 vuex，用法有两种：<a href="https://zh.nuxtjs.org/guide/vuex-store#普通方式" target="_blank" rel="noopener">普通方式</a>和<a href="https://zh.nuxtjs.org/guide/vuex-store#模块方式" target="_blank" rel="noopener">模块方式</a>，用法和我们常用的 vuex 一样。我的demo中是直接复制官网的代码。<br>需要注意的是，vuex 的数据会存在<a href="https://zh.nuxtjs.org/api/#上下文对象" target="_blank" rel="noopener">context对象</a>中，我们可以通过context对象获取状态数据。</p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>发布有两种方式服务器应用渲染部署和静态部署，发布方式<a href="https://zh.nuxtjs.org/guide/commands#发布部署" target="_blank" rel="noopener">看这里</a></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>去看 Nuxt.js 的 <a href="https://zh.nuxtjs.org/api" target="_blank" rel="noopener">API</a>，会发现 Nuxt.js 真的是高度封装。对于 Nuxt.js 生成的模板项目，只有一些必要配置是需要我们去完成的。Nuxt.js 可以说是一个非常友好而强大的 SSR 框架了。</p>
<h1 id="Vue-js学习系列"><a href="#Vue-js学习系列" class="headerlink" title="Vue.js学习系列"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>
<p><a href="http://www.jianshu.com/p/8013d8d37bd0" target="_blank" rel="noopener">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href="http://www.jianshu.com/p/d6f7e11f18af" target="_blank" rel="noopener">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href="http://www.jianshu.com/p/8e5fb763c3d7" target="_blank" rel="noopener">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href="http://www.jianshu.com/p/aef34acd111f" target="_blank" rel="noopener">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href="http://www.jianshu.com/p/efb6fbed6fac" target="_blank" rel="noopener">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href="http://www.jianshu.com/p/073d25a3bba0" target="_blank" rel="noopener">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href="https://www.jianshu.com/p/ba7466d7101a" target="_blank" rel="noopener">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href="https://www.jianshu.com/p/15028f91226e" target="_blank" rel="noopener">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>
<h1 id="Vue-js学习系列项目地址"><a href="#Vue-js学习系列项目地址" class="headerlink" title="Vue.js学习系列项目地址"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href="https://github.com/violetjack/VueStudyDemos" target="_blank" rel="noopener">https://github.com/violetjack/VueStudyDemos</a></p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>
<p>新浪微博： <a href="http://weibo.com/u/2640909603" target="_blank" rel="noopener">http://weibo.com/u/2640909603</a><br>掘金：<a href="https://gold.xitu.io/user/571d953d39b0570068145cd1" target="_blank" rel="noopener">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href="http://blog.csdn.net/violetjack0808" target="_blank" rel="noopener">http://blog.csdn.net/violetjack0808</a><br>简书： <a href="http://www.jianshu.com/users/54ae4af3a98d/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href="https://github.com/violetjack" target="_blank" rel="noopener">https://github.com/violetjack</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/01/26/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习/" data-id="cjdtq38ct0002wfbttoeu3qp9" class="article-share-link" data-share="baidu" data-title="Vue.js学习系列七 —— Vue服务器渲染Nuxt学习">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/01/26/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-ES6 学习笔记（下）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/ES6 学习笔记（下）/" class="article-date">
  <time datetime="2018-01-20T16:00:00.000Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/ES6 学习笔记（下）/">ES6 学习笔记（下）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>认真学习了一遍ES6，发现很多很好用的功能。<br>学习资料：<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">《ECMAScript 6 入门》</a></p>
</blockquote>
<p>好啦，继续下半部分的学习。</p>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 用于修改对象的某些操作行为。套用书上的栗子，实现了对象的set、get方法拦截。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get: function (target, key, receiver) &#123;</span><br><span class="line">        console.log(`getting $&#123;key&#125;!`);</span><br><span class="line">        return Reflect.get(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (target, key, value, receiver) &#123;</span><br><span class="line">        console.log(`setting $&#123;key&#125;!`);</span><br><span class="line">        return Reflect.set(target, key, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.count = 1</span><br><span class="line">obj.name = &apos;jack&apos;</span><br><span class="line">obj.count++</span><br><span class="line"></span><br><span class="line">// setting count</span><br><span class="line">// setting name</span><br><span class="line">// getting count</span><br><span class="line">// setting count</span><br></pre></td></tr></table></figure></p>
<p><strong>实例方法整理</strong></p>
<ul>
<li>get 方法拦截属性的读取操作。</li>
<li>set 方法拦截赋值操。</li>
<li>apply 方法拦截函数的调用。</li>
<li>has 方法拦截 <code>HasProperty</code> 操作，即查找对象中是否有某属性。可用来隐藏一些属性不被 <code>in</code> 运算符发现。</li>
<li>construct 方法拦截 <code>new</code> 指令。即在 <code>new</code> 指令创建实例的时候可以对对象中的参数进行一些初始化修改操作。</li>
<li>deleteProperty方法拦截 <code>delete</code> 指令，可用来保护某些对象属性无法被删除。</li>
<li>defineProperty方法拦截了Object.defineProperty操作。</li>
<li>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined</li>
<li>getPrototypeOf方法主要用来拦截获取对象原型。</li>
<li>isExtensible方法拦截Object.isExtensible操作。</li>
<li>ownKeys方法用来拦截对象自身属性的读取操作。</li>
<li>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</li>
<li>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</li>
</ul>
<p>apply方法的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var target = function () &#123; return &apos;I am the target&apos;; &#125;;</span><br><span class="line">var handler = &#123;</span><br><span class="line">    apply: function () &#123;</span><br><span class="line">        return &apos;I am the proxy&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">console.log(p())</span><br><span class="line">// &quot;I am the proxy&quot;</span><br></pre></td></tr></table></figure></p>
<p>has方法的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var handler = &#123;</span><br><span class="line">    has (target, key) &#123;</span><br><span class="line">        if (key[0] === &apos;_&apos;) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return key in target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var target = &#123; _prop: &apos;foo&apos;, prop: &apos;foo&apos; &#125;;</span><br><span class="line">var proxy = new Proxy(target, handler);</span><br><span class="line">console.log(&apos;_prop&apos; in proxy)</span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p>
<p>construct方法的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var p = new Proxy(function () &#123;&#125;, &#123;</span><br><span class="line">    construct: function(target, args) &#123;</span><br><span class="line">        console.log(&apos;called: &apos; + args.join(&apos;, &apos;));</span><br><span class="line">        return &#123; value: args[0] * 5 + 12 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(new p(1))</span><br><span class="line">console.log(new p(1).value)</span><br><span class="line"></span><br><span class="line">// call: 1</span><br><span class="line">// &#123; value: 17 &#125;</span><br><span class="line">// call: 1</span><br><span class="line">// 17</span><br></pre></td></tr></table></figure></p>
<p>所以，我理解的 Proxy 对象主要功能就是拦截对象属性的一些操作。</p>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>我理解的Reflect对象：</p>
<ul>
<li>是Object的高级版本，Object对对象的操作方法Reflect对象都有，并且未来操作对象的新方法只放在Reflect对象中有。</li>
<li>发生错误不会报错而是返回false，可直接在判断中使用。</li>
<li>让Object操作都变成函数行为，统一表现形式。某些Object操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code> ，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。Proxy对象拦截对象属性方法，进行重新定义。而Reflect对象立即执行对象属性方法。下面例子中使用set和get做演示。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2,</span><br><span class="line">    get baz() &#123;</span><br><span class="line">        return this.foo + this.bar;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Reflect.get(myObject, &apos;foo&apos;)) </span><br><span class="line">console.log(Reflect.get(myObject, &apos;bar&apos;)) </span><br><span class="line">console.log(Reflect.get(myObject, &apos;baz&apos;)) </span><br><span class="line"></span><br><span class="line">console.log(Reflect.set(myObject, &apos;foo&apos;, 100))</span><br><span class="line">console.log(myObject.foo)</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// true</span><br><span class="line">// 100</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><p>Promise 对象登场啦~这是 ES6 语法中非常常用的对象。<br>我理解的 Promise 对象：</p>
<ul>
<li>Promise 对象让异步操作的写法从回调函数变为链式操作，可读性更强。</li>
<li>Promise 对象一旦改变，就会锁死，不再改变。</li>
</ul>
<p><strong>基本用法</strong><br>Promise 的定义，定义一个 Promise对象，参数为resolve和reject，resolve为执行成功的方法，而reject为执行失败的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>基本调用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>Promise 函数一旦用 new 指令创建，立即执行。并且数据为不可变。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let success = true</span><br><span class="line">let name = &apos;jack&apos;</span><br><span class="line"></span><br><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&apos;create&apos;)</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        resolve(name)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(&apos;error promise&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">success = false</span><br><span class="line">name = &apos;rose&apos;</span><br><span class="line">console.log(&apos;before then&apos;)</span><br><span class="line"></span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// create</span><br><span class="line">// before then</span><br><span class="line">// jack</span><br></pre></td></tr></table></figure></p>
<p>由此可见，在定义了Promise之后，我们再去修改 <code>name</code> 返回的还是定义Promise时候的值。说明了Promise对象定义即执行，并且不可变。</p>
<p><strong>Promise 推荐使用 <code>promise.then().catch()</code>  写法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>then方法链式写法表达，then方法的返回值可以传递给下一个then方法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&apos;jack&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return &apos;violet&apos; + value</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return &apos;welcome to &apos; + value</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">    return  value + &apos; blog&apos;</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// jack</span><br><span class="line">// violetjack</span><br><span class="line">// welcome to violetjack</span><br><span class="line">// welcome to violetjack blog</span><br></pre></td></tr></table></figure></p>
<p><strong>catch方法用于捕获Promise对象的异常行为（可能是 reject 函数返回的错误，也可能是<code>throw new Error(&#39;error&#39;)</code>）。</strong><br><strong>Promise.all() 方法将多个Promise实例包装成一个Promise实例。如下示例，如果p1、p2、p3都执行成功，则执行then方法，返回的参数为三个实例的参数数组；如果有任意一个Promise实例报错，则在catch方法中返回该实例的错误信息。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&apos;jack&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // resolve(&apos;rose&apos;)</span><br><span class="line">    reject(&apos;rose error&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&apos;james&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2, p3]).then(values =&gt; &#123;</span><br><span class="line">    console.log(values)</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// [&quot;jack&quot;, &quot;rose&quot;, &quot;james&quot;]</span><br><span class="line">// rose error</span><br></pre></td></tr></table></figure></p>
<p><strong>Promise.race() 方法用法与 all 方法一致，唯一不同点就是多个 Promise实例中只作用域最快有反映的Promise实例，并且返回该实例的正确或错误信息。如果多个Promise同时触发，按顺序返回第一个Promise实例。</strong><br><strong>Promise.resolve() 和 Promise.reject()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br><span class="line"></span><br><span class="line">const p = Promise.reject(&apos;出错了&apos;);</span><br><span class="line">// 等同于</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</span><br></pre></td></tr></table></figure></p>
<h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><p><strong>默认Iterator接口部署在数据对象的 <code>Symbol.iterator</code> 属性中，<code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。只要数据对象有了 <code>Symbol.iterator</code> 属性就可以进行遍历。如下对象添加了 <code>Symbol.iterator</code>  属性后实现了遍历操作。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    data: [ &apos;hello&apos;, &apos;world&apos; ],</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        const self = this;</span><br><span class="line">        let index = 0;</span><br><span class="line">        return &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                if (index &lt; self.data.length) &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: self.data[index++],</span><br><span class="line">                        done: false</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return &#123; value: undefined, done: true &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([...obj])</span><br><span class="line"></span><br><span class="line">// [&quot;hello&quot;, &quot;world&quot;]</span><br></pre></td></tr></table></figure></p>
<p><strong>Iterator 接口主要供for…of消费。</strong><br><strong><code>for...in</code> 循环读取键名，<code>for...of</code> 循环读取键值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class="line"></span><br><span class="line">for(let v of arr) &#123;</span><br><span class="line">    console.log(v); // red green blue</span><br><span class="line">&#125;</span><br><span class="line">for(let k in arr)&#123;</span><br><span class="line">    console.log(k) // 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h1><p><strong>一种异步解决方案。函数执行返回一个对象，而函数中的数据只有在对象使用 next() 方法才会返回下一个用 <code>yield</code> 或者 <code>return</code> 定义的数据，否则对象状态就凝固在那里。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* helloGenerator() &#123;</span><br><span class="line">    yield &apos;hello&apos;</span><br><span class="line">    yield &apos;world&apos;</span><br><span class="line">    return &apos;generator&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var h = helloGenerator()</span><br><span class="line">console.log(h.next())</span><br><span class="line">console.log(h.next())</span><br><span class="line">console.log(h.next())</span><br><span class="line">console.log(h.next())</span><br><span class="line"></span><br><span class="line">// &#123; value: &apos;hello&apos;, done: false&#125;</span><br><span class="line">// &#123; value: &apos;world&apos;, done: false&#125;</span><br><span class="line">// &#123; value: &apos;generator&apos;, done: true&#125;</span><br><span class="line">// &#123; value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>next() 方法传值—— <code>next()</code> 方法返回的是 <code>yield</code> 表达式的计算结果。如果 <code>next(value)</code> 方法中传入value参数，则参数将替换上一个 <code>yield</code> 数据。如下示例中，<code>12</code> 替换了<code>(yield (x + 1))</code>，<code>13</code> 替换了<code>yield (y / 3)</code>，最后得到结果为42。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  // value  = 5 + 1</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  // y = 2 * 12 value = 24 / 3</span><br><span class="line">  return (x + y + z);</span><br><span class="line">  // z = 13 y = 24 z = 13 value = 5 + 24 + 13</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo(5);</span><br><span class="line">a.next() // Object&#123;value:6, done:false&#125;</span><br><span class="line">// 如果不传递数据，则y=NaN</span><br><span class="line">a.next() // Object&#123;value:NaN, done:false&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, done:true&#125;</span><br><span class="line"></span><br><span class="line">var b = foo(5);</span><br><span class="line"></span><br><span class="line">b.next() // &#123; value:6, done:false &#125;</span><br><span class="line">b.next(12) // &#123; value:8, done:false &#125;</span><br><span class="line">b.next(13) // &#123; value:42, done:true &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>throw方法用于捕捉错误，return方法类似于 Genterator 函数的 <code>return xxx</code> 返回某个值，随后再使用next方法返回的都是 <code>undefined</code></strong><br><strong>对于 next、throw、return，引用书上的解释更清晰点。</strong></p>
<blockquote>
<p><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值。<br><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句。<br><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句。</p>
</blockquote>
<p><code>yield*</code> <strong>用于将其他 Generator 函数合并到当前函数中，用法如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* bar() &#123;</span><br><span class="line">    yield &apos;a&apos;</span><br><span class="line">    yield &apos;b&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* foo() &#123;</span><br><span class="line">    yield &apos;x&apos;</span><br><span class="line">    yield* bar()</span><br><span class="line">    yield &apos;y&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of foo())&#123;</span><br><span class="line">    console.log(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// x</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// y</span><br></pre></td></tr></table></figure></p>
<p><strong>Generator 函数不能直接用 new 指令实例化对象，需要包装为普通函数再 new</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">  yield this.b = 2;</span><br><span class="line">  yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F() &#123;</span><br><span class="line">  return gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F();</span><br><span class="line"></span><br><span class="line">f.next();  // Object &#123;value: 2, done: false&#125;</span><br><span class="line">f.next();  // Object &#123;value: 3, done: false&#125;</span><br><span class="line">f.next();  // Object &#123;value: undefined, done: true&#125;</span><br><span class="line"></span><br><span class="line">f.a // 1</span><br><span class="line">f.b // 2</span><br><span class="line">f.c // 3</span><br></pre></td></tr></table></figure></p>
<p><strong>自动执行所有Generator函数的方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123;</span><br><span class="line">  var gen = fn();</span><br><span class="line"></span><br><span class="line">  function next(err, data) &#123;</span><br><span class="line">    var result = gen.next(data);</span><br><span class="line">    if (result.done) return;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* g() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure></p>
<p><strong>以上自动执行器还可以使用 <code>co</code> 模块来实现。</strong></p>
<h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><p>async函数用于处理异步操作，它是对Generator函数的改进。它相比于Generator有以下几个优点：</p>
<ul>
<li>内置执行器：相比于Generator 要自定义或者用 co 模块来实现自动执行器效果，async函数自带自动执行器。</li>
<li>更好的语义：async 和 await，比起 * 和 yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
<li>更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
<li>返回Promise：async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</li>
</ul>
<p>我个人对async的感觉是写法方便、代码理解简单、代码写法也符合逻辑、操作异步行为方便。<br>下面写了 Generator 函数和 async 函数实现异步的代码的对比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const readFile = function (fileName) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(`reading $&#123;fileName&#125;`)</span><br><span class="line">            resolve(fileName)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Generator 写法</span><br><span class="line">const gen = function* () &#123;</span><br><span class="line">    const f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">    const f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var g = gen()</span><br><span class="line">g.next().value.then(value =&gt; &#123;</span><br><span class="line">    g.next(value).value.then(value =&gt; &#123;</span><br><span class="line">        g.next(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// async 写法</span><br><span class="line">async function gan() &#123;</span><br><span class="line">    const f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class="line">    const f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gan()</span><br></pre></td></tr></table></figure></p>
<p>两种函数的实现结果是一样的。<br>但从上面的例子中可以看出，Generator 函数需要不断调用next方法，并且将上一个next方法的结果传递给当前next方法当做参数。而async函数直接调用函数本身就会自动往下执行。Generator多了一步执行的过程。<br>另外，async await的语义很清晰，就算没学过ES6的大致都能看懂是什么意思啦~</p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>class其实就是一个函数实例化的语法糖~具体功能也类似Java这类有Class的语言~<br>所以，下面两种写法的结果是相等的。<br><strong>传统写法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function () &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p = new Point(1, 2);</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure></p>
<p><strong>ES6 Class写法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Point(1, 2);</span><br><span class="line">console.log(p)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1987062-3f972d9e15d96308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"><br>对象结果如上图所示，构造函数中this对象的属性在实例中，而Class里面的函数再实例对象的 <code>__proto__</code> 中。<br><strong>使用 <code>new target</code> 在构造函数中判断对象是否为 <code>new</code> 指令创建的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 另一种写法</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  if (new.target === Person) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error(&apos;必须使用 new 命令生成实例&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;张三&apos;); // 正确</span><br><span class="line">var notAPerson = Person.call(person, &apos;张三&apos;);  // 报错</span><br></pre></td></tr></table></figure></p>
<h1 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h1><p>类似于Java的修饰器 <code>@Override</code> ， 现有一个提案，将修饰器加入到 ECMAScript 中。</p>
<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><p>在 ES6 中添加了模块化功能，很常见用法也很简单。<br><strong>模块加载</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; // 多个模块加载</span><br><span class="line">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;; // 模块加载重命名</span><br><span class="line">import * as circle from &apos;./circle&apos;; // 整理加载</span><br></pre></td></tr></table></figure></p>
<p><strong>模块输出</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 输出变量</span><br><span class="line">export let a = 100</span><br><span class="line">// 输出方法</span><br><span class="line">export function hello() &#123;</span><br><span class="line">    console.log(&apos;hello world&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 输出多个变量</span><br><span class="line">const b = 200</span><br><span class="line">const c = 300</span><br><span class="line">const d = 400</span><br><span class="line">export &#123;b, c, d&#125;</span><br><span class="line">// 输出变量重命名</span><br><span class="line">export &#123;b as value&#125;</span><br><span class="line">// 输出默认值</span><br><span class="line">export default function () &#123;</span><br><span class="line">    console.log(&apos;hello default&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><code>CommonJS</code> 语法中模块输出和加载的写法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h1><p>ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。</p>
<blockquote>
<p><strong>二进制数组由三类对象组成。</strong><br>（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。<br>（2）TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。<br>（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。<br>简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray 视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。</p>
</blockquote>
<p>这方面知识点不太常用，了解下，等到用的时候查查就是了。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/style" target="_blank" rel="noopener">编程风格</a> —— 主要参考了 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb</a> 公司的 JavaScript 风格规范。</li>
<li><a href="http://es6.ruanyifeng.com/#docs/spec" target="_blank" rel="noopener">读懂 ECMAScript 规格</a> —— 对于规格的学习建议，阮一峰老师的建议如下：<blockquote>
<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。<br>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>
</blockquote>
</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>好啦~终于把下半部分写完了。有点虎头蛇尾，一开始写的东西很具体，到后来内容有点少。主要是因为前面部分我觉得是比较麻烦和常用的。写这篇博客主要是系统复习下ES6语法，简略地提一下各个语法的用法、注意点。大致知道了有些什么，以后遇到问题知道如何查资料如何解决就好了。<br>感觉自己写博客速度忒慢了，写ES6笔记断断续续花了我十个小时……<br>最后呢，还是那句话——<strong>由自己整理写出博客的知识点才是真正牢牢掌握的知识点！</strong>至此，我对ES6语法的理解加深了很多。看到此文的你可以去试试用写博客的方式来复习知识点哦~<br>希望我写的东西能帮助到一些朋友。</p>
<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>VioletJack，内驱工程师~专注于Vue前端相关的知识点整理、源码学习、内容分享。欢迎喜欢我文章的朋友关注我哦，我会努力产出优质内容~让我们始终相信：code change world!</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/01/21/ES6 学习笔记（下）/" data-id="cjdtq38cr0001wfbti5793ug6" class="article-share-link" data-share="baidu" data-title="ES6 学习笔记（下）">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/01/21/ES6 学习笔记（下）/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-ES6 学习笔记（上）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/ES6 学习笔记（上）/" class="article-date">
  <time datetime="2018-01-17T16:00:00.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/ES6 学习笔记（上）/">ES6 学习笔记（上）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>认真学习了一遍ES6，发现很多很好用的功能。<br>学习资料：<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">《ECMAScript 6 入门》</a></p>
</blockquote>
<p>之前写JS，虽然也遇到一些ES6语法，基本就是理解就行，没有深入学习过。这次认真看了一遍ES6，发现里面有许多实用的东西。下面是对本书学习的一些笔记</p>
<h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><p>解决var变量提升、变量全局的问题。</p>
<p><strong>let 和 const 都只作用域本块级作用域内。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 123</span><br><span class="line">&#123;</span><br><span class="line">    let a = 456</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br><span class="line">// 456</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure></p>
<p><strong>let 和 const 定义的变量不能同名。</strong><br><strong>let 和 const 定义的变量不可以变量提升。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">let a</span><br><span class="line"></span><br><span class="line">// Error: a is not defined</span><br></pre></td></tr></table></figure></p>
<p><strong>const定义的量内存不可变</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const a = 6</span><br><span class="line">const obj = &#123;</span><br><span class="line">    name: &apos;violetjack&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以下写法会报错，因为他们指向了另一个内存地址</span><br><span class="line">// a = 6</span><br><span class="line">// obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.name = &apos;jerry&apos;</span><br><span class="line">obj.age = 56</span><br><span class="line">console.log(obj)</span><br><span class="line"></span><br><span class="line">// &#123; name: &apos;jerry&apos;, age: 56 &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="变量的结构与赋值"><a href="#变量的结构与赋值" class="headerlink" title="变量的结构与赋值"></a>变量的结构与赋值</h1><p>快速赋值，优化代码可读性。</p>
<p><strong>用法都差不多，一一对应即可</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3] // 数组结构</span><br><span class="line">let &#123; name:mName, age: mAge&#125; = &#123; name:&apos;violetjack&apos;, age: 28 &#125; // 对象结构</span><br><span class="line">let [e,f,g] = &apos;mmp&apos; // 字符串结构</span><br><span class="line">console.log(a)</span><br><span class="line">console.log(mName)</span><br><span class="line">console.log(e + f + g)</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">// violetjack</span><br><span class="line">// mmp</span><br></pre></td></tr></table></figure></p>
<h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><p>提出了一些处理字符串的方式</p>
<p><strong>提供了一些处理大于 <code>0xFFFF</code> 的字符串的方法</strong><br><strong>字符串检索</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br><span class="line"></span><br><span class="line">// includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line">// startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line">// endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br></pre></td></tr></table></figure></p>
<p><strong>可以操作复制、填充字符串：<code>repeat</code>,<code>padStart</code>,<code>padEnd</code></strong><br><strong>模板字符串，解决字符串拼接问题。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;VioletJack&apos;</span><br><span class="line">const str = &apos;welcome to &apos; + name + &quot;&apos;s blog&quot;</span><br><span class="line">const str2 = `welcome to $&#123;name&#125;&apos;s blog`</span><br><span class="line">console.log(str)</span><br><span class="line">console.log(str2)</span><br><span class="line"></span><br><span class="line">// welcome to VioletJack&apos;s blog</span><br><span class="line">// welcome to VioletJack&apos;s blog</span><br></pre></td></tr></table></figure></p>
<p>相比于第一种方式，第二种方式可读性好很多。也避免了在使用 <code>&#39;</code> <code>&quot;</code> 两个符号的时候需要转译的步骤。同时在引用数据上使用 <code>${value}</code> 的方式引用。非常方便！</p>
<h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><p>对于正则我一向晕晕乎乎，没啥收获。关于正则我要另外写篇博客涨涨姿势。</p>
<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><p>主要提供了一些数字高级算法。<br><strong>parseInt和parseFloat都在Number中调用，减少js中的全局方法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">parseInt(&apos;12.34&apos;) // 12</span><br><span class="line">parseFloat(&apos;123.45#&apos;) // 123.45</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Number.parseInt(&apos;12.34&apos;) // 12</span><br><span class="line">Number.parseFloat(&apos;123.45#&apos;) // 123.45</span><br></pre></td></tr></table></figure></p>
<p><strong>求指数，通过 `</strong>` 实现**<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2 // 2*2 = 4</span><br><span class="line">2 ** 3 // 2*2*2 = 8</span><br></pre></td></tr></table></figure></p>
<p>其他数学算法就不一一列举了，基本用不着，用到了百度即可。</p>
<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><p>在函数参数传递方面实现了更多传递方式，实现了箭头函数。总体上是让函数应用上ES6的结构、<code>rest</code> 参数。此外还有几个提案，可以去书上看看。</p>
<p><strong>更多的参数传递方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 函数参数默认值</span><br><span class="line">function func01(a, b = 11) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func01(15)</span><br><span class="line">func01(10, undefined)</span><br><span class="line">func01(1, 1)</span><br><span class="line"></span><br><span class="line">// 参数解构</span><br><span class="line">function func02(&#123;a = 6, b&#125;) &#123;</span><br><span class="line">    console.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func02(&#123;a: 11, b: 12&#125;)</span><br><span class="line">func02(&#123;b: 6&#125;)</span><br><span class="line"></span><br><span class="line">// rest参数</span><br><span class="line">function func03(...vals) &#123;</span><br><span class="line">    let count = 0</span><br><span class="line">    for (let value of vals) &#123;</span><br><span class="line">        count += value</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func03(1, 2, 3, 4, 5)</span><br><span class="line">func03(11, 22, 33, 44, 55)</span><br></pre></td></tr></table></figure></p>
<p><strong>提出箭头函数，简化代码。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function(v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意如果参数或者返回结果是对象，需要用<code>()</code>包裹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fun = (&#123; a, b &#125;) =&gt; a + b</span><br><span class="line">var fun02 = a =&gt; (&#123; value: a &#125;)</span><br></pre></td></tr></table></figure></p>
<p>另外一个特别要注意的就是 <code>this</code>，我看到过好几篇博客来解释箭头函数的 <code>this</code> 的，可见这个 <code>this</code> 的特殊性。可以<a href="https://juejin.im/search?query=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">在掘金搜索箭头函数</a>，里面全是解释（tu cao）箭头函数的~<br>下面搬运书上对箭头函数的注意点。</p>
<blockquote>
<p>箭头函数有几个使用注意点。<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
</blockquote>
<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><p><strong>扩展运算符，和函数中的rest参数是一回事。我的理解就是把数组拆分成一个个值。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4]</span><br><span class="line">console.log(...arr)</span><br><span class="line">console.log([0, 8, 6, ...arr, 10])</span><br><span class="line">let str = &apos;jack&apos;</span><br><span class="line">console.log(...str)</span><br><span class="line"></span><br><span class="line">// 1 2 3 4</span><br><span class="line">// [ 0, 8, 6, 1, 2, 3, 4, 10 ]</span><br><span class="line">// j a c k</span><br></pre></td></tr></table></figure></p>
<p><strong>Array.from 将类数组对象转为真正的数组。</strong><br><strong>Array.of 将多个值转为数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) </span><br><span class="line">// [3,11,8]</span><br></pre></td></tr></table></figure></p>
<p><strong>copyWithin 将数组中某些内容来替换指定内容</strong><br><strong>find 和 findIndex 用于找到数组中第一个符合条件的值和索引位置。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 4, -5, 10].find((n) =&gt; n &lt; 2)</span><br><span class="line">console.log(a)</span><br><span class="line">var b = [1, 5, 10, 15].findIndex(function (value, index, arr) &#123;</span><br><span class="line">    return value &gt; 11;</span><br><span class="line">&#125;) </span><br><span class="line">console.log(b)</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p>
<p><strong>fill 用于填充数组</strong><br><strong>entries、keys和values用来遍历数组非常方便，通过不同方法返回所需数组内容。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>includes 方法与字符串的 includes 类似，用于查找数组中是否有某个值，返回布尔类型的值。</strong><br><strong>ES6中将数组空位转为undefined</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([...[&apos;a&apos;,,&apos;b&apos;]])</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure></p>
<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><p><strong>对象属性的简洁表示法，也就是我们常看到的ES6的写法。对象中不再必须要传递 <code>key-value</code> 的形式了。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a = 12</span><br><span class="line">let b = 22</span><br><span class="line">let obj = &#123; a, b &#125;</span><br><span class="line">console.log(obj)</span><br><span class="line"></span><br><span class="line">// &#123; a: 12. b: 22 &#125;</span><br><span class="line"></span><br><span class="line">let obj02 = &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        console.log(&apos;Hello!&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对于对象属性名，支持使用 <code>[字符串]</code> 的形式来作为对象属性名。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    [&apos;age&apos;]: 28,</span><br><span class="line">    [&apos;se&apos; + &apos;x&apos;]: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj)</span><br><span class="line"></span><br><span class="line">// &#123;name: &quot;jack&quot;, age: 28, sex: &quot;male&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Object.is方法用于比较两个值是否严格相等。</strong><br><strong>Object.assign 用于对象的合并，如果有同名属性，后添加的覆盖之前的属性。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;</span><br><span class="line">    name: &apos;jack&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;</span><br><span class="line">    [&apos;age&apos;]: 28,</span><br><span class="line">    [&apos;se&apos; + &apos;x&apos;]: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj3 = &#123;</span><br><span class="line">    job: &apos;js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj4 = &#123;</span><br><span class="line">    name: &apos;rose&apos;,</span><br><span class="line">    hobby: &apos;game&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(obj1, obj2, obj3, obj4)</span><br><span class="line">console.log(obj1)</span><br><span class="line"></span><br><span class="line">// &#123;name: &quot;rose&quot;, age: 28, sex: &quot;male&quot;, job: &quot;js&quot;, hobby: &quot;game&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对象的<strong>proto</strong>属性是一个内部属性，所以前后有下划线。不建议修改该属性。</strong><br><strong>ES6的super关键字用于继承，可以理解为java的super关键字。</strong><br><strong>Object.keys()，Object.values()，Object.entries()和Array的类似，是对对象的一个遍历过程。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let &#123;keys, values, entries&#125; = Object;</span><br><span class="line">let obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">for (let key of keys(obj)) &#123;</span><br><span class="line">  console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let value of values(obj)) &#123;</span><br><span class="line">  console.log(value); // 1, 2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of entries(obj)) &#123;</span><br><span class="line">  console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>在对象中也可以使用扩展运算符 <code>...</code></strong></p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>这玩意的用处我不太理解，就是为了表示一个唯一的值？<br><strong>ES6 的7中原始数据类型：<code>Symbol</code>、<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Object</code></strong></p>
<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><p><strong>Set是一个构造函数，它的值都是唯一的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 2 3 5 4</span><br></pre></td></tr></table></figure></p>
<p><strong>Set可用于去除数组中的重复项。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>
<p><strong>操作Set的语法如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(value)：添加某个值，返回 Set 结构本身。</span><br><span class="line">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</span><br><span class="line">has(value)：返回一个布尔值，表示该值是否为Set的成员。</span><br><span class="line">clear()：清除所有成员，没有返回值。</span><br></pre></td></tr></table></figure></p>
<p><strong>WeakSet与Set的不同点</strong></p>
<blockquote>
<p>WeakSet 的成员只能是对象，而不能是其他类型的值。<br>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
</blockquote>
<p><strong>Map不同于传统Object对象的地方在于，Object的属性名只能是String类型的。而Map可以有任意类型的属性名。</strong><br><strong>Map的key如果是一个对象，那么这个key应该指向同一个内存（可以用const定义之后再当做参数传入map作为属性名。）。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// error</span><br><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br><span class="line"></span><br><span class="line">// success</span><br><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">const k1 = [&apos;a&apos;];</span><br><span class="line">const k2 = [&apos;a&apos;];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, 111)</span><br><span class="line">.set(k2, 222);</span><br><span class="line"></span><br><span class="line">map.get(k1) // 111</span><br><span class="line">map.get(k2) // 222</span><br></pre></td></tr></table></figure></p>
<p><strong>WeakMap与Map的区别：</strong></p>
<blockquote>
<p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
</blockquote>
<p>好吧，暂时先到这儿。另外一部分后面继续整理吧~知识点还是蛮多的。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2018/01/18/ES6 学习笔记（上）/" data-id="cjdtq38co0000wfbt59c04hl1" class="article-share-link" data-share="baidu" data-title="ES6 学习笔记（上）">分享到</a>
      

      
        <a href="https://violetjack.github.io/2018/01/18/ES6 学习笔记（上）/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-weex项目弃坑小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/01/weex项目弃坑小结/" class="article-date">
  <time datetime="2017-11-30T16:00:00.000Z" itemprop="datePublished">2017-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/01/weex项目弃坑小结/">weex项目弃坑小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>由于<code>weex</code> 的不稳定性，所以中途放弃了 <code>weex</code> 方案。转而使用 Android原生开发。今天项目第一阶段开发结束，来总结一下 <code>weex</code> 的一些东西。</p>
</blockquote>
<p><code>weex</code> 相比于原生开发的好处</p>
<ul>
<li>界面搭建速度快，特别是重复性界面。</li>
<li>数据处理方便，尤其是json解析方面。</li>
</ul>
<p>坏处么</p>
<ul>
<li>用的人太少，所以网上资料也很少。</li>
<li>坑还是比较多的，要玩的溜要踩上不少坑。</li>
<li>还是需要一些原生开发的知识才能够玩的溜。</li>
</ul>
<p>说说我这个项目的一些东西吧~</p>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>第一个困扰我的就是页面跳转，我去SF上提问了<a href="https://segmentfault.com/q/1010000009999942" target="_blank" rel="noopener">Weex的页面跳转方案的选择</a>这个问题。</p>
<ul>
<li><code>vue-router</code> 方案由于 <code>Vue</code>和 <code>weex</code> 的差异性，用法有所不同，好像需要使用注入 <code>minixs</code> 机制，挺麻烦的，所以放弃了……这个如果有需要我会再去研究一下的。</li>
<li>第二种方案就是每个页面都是单独的 <code>Activity</code>，各自嵌入一个 <code>weex</code> 页面。但是有个问题：<code>weex</code> 如何与当前 <code>Activity</code> 交互，比如我要从页面A跳转到页面B，我需要 <code>weex</code> 调用 <code>Activity</code> 的 <code>startActivity</code> 方法，这个交互方式我没有找到。不然倒是可以随心所欲的在原生开发和weex之间来回交互。暂时来说我只知道<a href="http://blog.csdn.net/violetjack0808/article/details/74002599" target="_blank" rel="noopener">通过globalEvent和Module扩展来实现两者的交互</a></li>
<li>最后，还是选择了官方推荐的 <code>Navigator</code> 来作为页面跳转的方式。这种方式能够很快速的实现页面跳转。不用瞎折腾~</li>
</ul>
<p>选定方案之后，就要解决几个问题了。多页面打包和跳转所需的 <code>Activity</code> 。</p>
<h3 id="多页面打包"><a href="#多页面打包" class="headerlink" title="多页面打包"></a>多页面打包</h3><p><code>navigator</code> 的跳转方式，需要获取打包好的 <code>weex</code> 的文件路径来进行页面跳转和显示，所以我们就需要多页 <code>weex</code> 文件代表每一个页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.push(&#123;</span><br><span class="line">  url: &apos;http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js&apos;,</span><br><span class="line">  animated: &quot;true&quot;</span><br><span class="line">&#125;, event =&gt; &#123;</span><br><span class="line">  modal.toast(&#123; message: &apos;callback: &apos; + event &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>需要配置 <code>Webpack</code> 来实现这一目的。我将每个页面的入口文件都放在 <code>./src/entrys</code>文件夹下，通过 <code>node</code> 的 <code>fs文件模块</code> 读取里面的入口文件，并将他们传给 <code>entry</code> 入口对象。最后将入口对象配置到 <code>webpack</code> 打包配置中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">var files = fs.readdirSync(&apos;./src/entrys&apos;)</span><br><span class="line">var entry = &#123;&#125;</span><br><span class="line">files.forEach(function (file) &#123;</span><br><span class="line">  var item = file.replace(&apos;.js&apos;, &apos;&apos;)</span><br><span class="line">  entry[item] = path.resolve(&apos;./src/entrys/&apos; + file)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var bannerPlugin = new webpack.BannerPlugin(</span><br><span class="line">  &apos;// &#123; &quot;framework&quot;: &quot;Vue&quot; &#125;\n&apos;, &#123; raw: true &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">function getBaseConfig() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    entry: entry,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: &apos;dist&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        &apos;@&apos;: path.resolve(&apos;./src&apos;),</span><br><span class="line">        &apos;views&apos;: path.resolve(&apos;./src/views&apos;),</span><br><span class="line">        &apos;utils&apos;: path.resolve(&apos;./src/utils&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">      // ESLint配置</span><br><span class="line">      preLoaders: [&#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        loader: &apos;eslint&apos;,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;eslint&apos;,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">      ],</span><br><span class="line">      // 如果注释掉以上这段将不产生ESLint检查</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel&apos;,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: /\.vue(\?[^?]+)?$/,</span><br><span class="line">        loaders: []</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    vue: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [bannerPlugin]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var webConfig = getBaseConfig()</span><br><span class="line">webConfig.output.filename = &apos;[name].web.js&apos;</span><br><span class="line">webConfig.module.loaders[1].loaders.push(&apos;vue&apos;)</span><br><span class="line"></span><br><span class="line">var weexConfig = getBaseConfig()</span><br><span class="line">weexConfig.output.filename = &apos;[name].weex.js&apos;</span><br><span class="line">weexConfig.module.loaders[1].loaders.push(&apos;weex&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = [webConfig, weexConfig]</span><br></pre></td></tr></table></figure></p>
<p>每一个入口文件都会产生两个相应名称的文件，如 <code>sign.js</code> 的入口文件就会生成 <code>sign.weex.js</code> 和 <code>sign.web.js</code> 文件，这里我们只关注 <code>weex</code> 后缀的文件，这就是我们跳转页面所需的文件。具体项目结构请看<a href="https://github.com/violetjack/MobileNurseWeex" target="_blank" rel="noopener">源代码</a><br>更多对于 <code>webpack</code> 的了解可以看<a href="http://blog.csdn.net/violetjack0808/article/details/54915825" target="_blank" rel="noopener">Vue.js学习系列四——Webpack学习实践</a></p>
<h3 id="navigator跳转的Activity哪里来的？"><a href="#navigator跳转的Activity哪里来的？" class="headerlink" title="navigator跳转的Activity哪里来的？"></a>navigator跳转的Activity哪里来的？</h3><p>在使用了 <code>navigator</code> 后一开始发现并没有页面跳转效果，而是报 <code>ActivityNotFoundException</code> 的错误。后来装了 <code>weex</code> 的 playground 之后发现可以跳转了，但是跳转过去的 <code>Activity</code> 有个 ActionBar 和一个性能调试的悬浮窗，是 playground 里面扫二维码显示的结果的那个 <code>Activity</code>。几经查阅后发现原来跳转的 <code>Activity</code> 是一个有着特殊 <code>intent-filter</code> 的 <code>Activity</code> 。<br>关于这个问题我写过一篇文章：<a href="http://blog.csdn.net/violetjack0808/article/details/74390249" target="_blank" rel="noopener">WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错</a><br>解决方案是我把 Playground 里面的那个 <code>Activity</code> 移到了我的项目中来，并且去除了 <code>ActionBar</code> 和调试工具。然后卸载掉 <code>weex</code>  的 Playground，这样就能愉快的显示 <code>navigator</code> 跳转的 <code>Activity</code> 了。代码请看<a href="https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/activity/WXPageActivity.java" target="_blank" rel="noopener">WXPageActivity</a>。</p>
<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络通信上我用的是stream，这个很简单。说下两点：<br>第一，stream所用的url需要是UTF-8格式的，如果URL中有中文需要转一下，URL可以参照utf8这个文件。<br>第二，提交数据的时候需要添加头文件。我的项目中是这样~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stream.fetch(&#123;</span><br><span class="line">  method: StreamType,</span><br><span class="line">  type: &apos;json&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  url: url,</span><br><span class="line">  body: JSON.stringify(this.DataObj)</span><br><span class="line">&#125;, res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">  let json = eval(&apos;(&apos; + res.data + &apos;)&apos;)</span><br><span class="line">  modal.alert(&#123;</span><br><span class="line">    message: json.Message</span><br><span class="line">  &#125;, event =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><p>图片加载需要在<a href="https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/ImageAdapter.java" target="_blank" rel="noopener">ImageAdapter</a>中稍作处理，我这里用的是 <code>Picasso</code> 来显示图片的~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ImageAdapter implements IWXImgLoaderAdapter &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123;</span><br><span class="line">        WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (view == null || view.getLayoutParams() == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (TextUtils.isEmpty(url)) &#123;</span><br><span class="line">                    view.setImageBitmap(null);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                String temp = url;</span><br><span class="line">                if (url.startsWith(&quot;//&quot;)) &#123;</span><br><span class="line">                    temp = &quot;http:&quot; + url;</span><br><span class="line">                &#125;</span><br><span class="line">                if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                Picasso.with(WXEnvironment.getApplication())</span><br><span class="line">                        .load(temp)</span><br><span class="line">                        .into(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="页面跳转的数据传输"><a href="#页面跳转的数据传输" class="headerlink" title="页面跳转的数据传输"></a>页面跳转的数据传输</h3><p>这一点上，我只想到了不太优雅的方式——使用 <code>storage</code> 来保存和读取。比如我需要将表单ID传递到下一个页面我是这么做的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">toDetail(AssessID) &#123;</span><br><span class="line">  storage.setItem(&apos;AssessID&apos;, AssessID)</span><br><span class="line">  navigator.push(&#123;</span><br><span class="line">    url: ViewServer + &apos;GAD.weex.js&apos;,</span><br><span class="line">    animated: &apos;true&apos;</span><br><span class="line">  &#125;, event =&gt; &#123;</span><br><span class="line">    console.log(&apos;successful entry&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>到第二个页面去获取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getData() &#123;</span><br><span class="line">  let that = this</span><br><span class="line">  storage.getItem(&apos;AssessID&apos;, event =&gt; &#123;</span><br><span class="line">    let AssessID = event.data</span><br><span class="line">    console.log(&apos;AssessID = &apos; + AssessID)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>如果是比较多的数据，我会将数据以 <code>json</code> 字符串的形式保存，在需要的时候获取字符串并解析为 <code>json</code> 对象。</p>
<h3 id="如何在返回上一页面时做一些操作？"><a href="#如何在返回上一页面时做一些操作？" class="headerlink" title="如何在返回上一页面时做一些操作？"></a>如何在返回上一页面时做一些操作？</h3><p>我的解决方法是在Activity的onResume方法中发送一个消息，然后在weex端添加监听事件。<br><strong>Android端</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    if (mInstance != null) &#123;</span><br><span class="line">        mInstance.onActivityResume();</span><br><span class="line"></span><br><span class="line">        new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span><br><span class="line">                mInstance.fireGlobalEventCallback(&quot;onResume&quot;, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>weex端</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addListener() &#123;</span><br><span class="line">     globalEvent.addEventListener(&apos;onResume&apos;, e =&gt; &#123;</span><br><span class="line">       storage.getItem(&apos;PopCallback&apos;, event =&gt; &#123;</span><br><span class="line">         if (event.data === &apos;update level list&apos;) &#123;</span><br><span class="line">           this.loadData()</span><br><span class="line">           storage.setItem(&apos;PopCallback&apos;, &apos;&apos;)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>由于加载 <code>weex</code> 有一些延时，<code>onResume</code> 往往会比 <code>weex</code> 加载快，所以我在 <code>onResume</code> 中添加了0.5秒延时。之后在 <code>weex</code> 中添加监听器监听 <code>onResume</code> 的生命周期，并监听返回的数据。</p>
<h3 id="如何控制weex的Slider显示第几页"><a href="#如何控制weex的Slider显示第几页" class="headerlink" title="如何控制weex的Slider显示第几页"></a>如何控制weex的Slider显示第几页</h3><p>想实现Android的ViewPager效果，使用了weex提供的slider组件，具体坚决方案看<a href="https://segmentfault.com/q/1010000010728251" target="_blank" rel="noopener">如何控制weex的Slider显示第几页。</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>图片的存放好像只能是网络图片的URL，所以我将所有图片都放到服务器上让weex去访问。</li>
<li>CSS使用flex布局来做，官网上有例子。也可参照<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>。</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>啰嗦一大堆，希望某些东西能够对他人有所帮助吧~<br>项目地址<a href="https://github.com/violetjack/MobileNurseWeex" target="_blank" rel="noopener">在此</a>，由于是公司项目，所以把服务器地址去掉了，后端数据获取不了。不过代码都是在的，可以进行参考。希望能对大家有所帮助~<br>最终不用weex的原因么，因为这玩意看似简单，但是想实现点复杂的、和原生交互的功能都得折腾好一会儿。关键还是资料太少，不靠谱，万一哪个地方报个奇怪的错误找不出问题、查不到资料、看不懂源码，那不就挂了嘛~所以，爱折腾玩玩可以，放项目中还是有待考虑。毕竟还是要求稳~</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="https://violetjack.github.io/2017/12/01/weex项目弃坑小结/" data-id="cjdtq38dx000kwfbtwm2gqmxu" class="article-share-link" data-share="baidu" data-title="weex项目弃坑小结">分享到</a>
      

      
        <a href="https://violetjack.github.io/2017/12/01/weex项目弃坑小结/#ds-thread" class="article-comment-link">评论</a>
      

      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/19/Vue.js源码学习四 —— 渲染 Render 初始化过程学习/">Vue.js源码学习四 —— 渲染 Render 初始化过程学习</a>
          </li>
        
          <li>
            <a href="/2018/02/17/Vue.js源码学习三 —— 事件 Event 学习/">Vue.js源码学习三 —— 事件 Event 学习</a>
          </li>
        
          <li>
            <a href="/2018/02/16/Vue.js源码学习二 —— 生命周期 LifeCycle 学习/">Vue.js源码学习二 —— 生命周期 LifeCycle 学习</a>
          </li>
        
          <li>
            <a href="/2018/02/08/用hexo搭建博客笔记/">用hexo搭建博客笔记</a>
          </li>
        
          <li>
            <a href="/2018/02/03/Vue.js源码学习一 —— 数据选项 State 学习/">Vue.js源码学习一 —— 数据选项 State 学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">个人网站</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/violetjack" target="_blank">Github</a>
          </li>
        
          <li>
            <a href="https://segmentfault.com/u/violetjack" target="_blank">SegmentFault</a>
          </li>
        
          <li>
            <a href="http://blog.csdn.net/violetjack0808" target="_blank">CSDN</a>
          </li>
        
          <li>
            <a href="https://www.jianshu.com/u/54ae4af3a98d" target="_blank">简书</a>
          </li>
        
          <li>
            <a href="https://juejin.im/user/571d953d39b0570068145cd1" target="_blank">掘金</a>
          </li>
        
          <li>
            <a href="https://www.zhihu.com/people/violetjack" target="_blank">知乎</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 VioletJack<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
