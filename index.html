<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。">
<meta property="og:type" content="website">
<meta property="og:title" content="VioletJack 技术日志">
<meta property="og:url" content="https://violetjack.github.io/index.html">
<meta property="og:site_name" content="VioletJack 技术日志">
<meta property="og:description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VioletJack 技术日志">
<meta name="twitter:description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。">



  <link rel="alternate" href="/atom.xml" title="VioletJack 技术日志" type="application/atom+xml"/>




  <link rel="canonical" href="https://violetjack.github.io/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>VioletJack 技术日志</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">VioletJack 技术日志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注！坚持！求真！</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>Über</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archiv</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2019/02/15/vue-react/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/15/vue-react/" class="post-title-link" itemprop="url">从 Vue 转 React 的一些体验</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-15T00:00:00+08:00">2019-02-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原本打算自己写一写 Vue 转 React 的体验的，但是掘金上一搜发现一些不错的文章。这里就不进行技术细节上的对比了，只说下体验。</p>
</blockquote>
<h1 id="使用-Vue-和-React-的区别"><a href="#使用-Vue-和-React-的区别" class="headerlink" title="使用 Vue 和 React 的区别"></a>使用 Vue 和 React 的区别</h1><p>如果对于两者的区别感兴趣可以看下下面两篇文章：</p>
<ul>
<li><a href="https://juejin.im/post/5c2de832f265da6172659b45" target="_blank" rel="noopener">「Vue」与「React」–使用上的区别</a></li>
<li><a href="https://juejin.im/post/5b8b56e3f265da434c1f5f76" target="_blank" rel="noopener">个人理解Vue和React区别</a></li>
</ul>
<p>看了上面两篇文章简单整理出以下几点区别：</p>
<ol>
<li>Vue 使用 setter/getter 实现双向绑定，React 根据数据渲染页面。</li>
<li>Vue 使用 props 向子组件通信，使用 events 向父组件通信。React 通过 props 传递数据和回调函数进行父子组件间通信。</li>
<li>Vue 使用 mixins 而 React 使用 HOC 高阶组件组合功能。</li>
<li>Vue 使用 provide/inject 进行跨层级组件通信，React 通过 context 进行跨层级组件通信。</li>
<li>模板渲染方式上，Vue 通过 v-if/v-show/v-for 语法糖封装的逻辑来渲染，而 React 通过原生 JavaScript 代码逻辑来渲染。</li>
<li>状态管理上，Vuex 和 Redux 思路差不多。但是 Vuex 是双向绑定的，状态可变；而 Redux 的数据是不可变的，采取整体替换的方式更新状态。</li>
<li>Vue 中的 computed 和 watch 属性在 React 中并没有，需要手写逻辑控制或者使用外部工具，如 mobx。</li>
<li>Vue 使用 slot 标签来实现组件嵌套，而 React 通过将需要嵌套的组件当做 props 传给子组件的方式来实现嵌套。</li>
<li>Vue 和 React 的生命周期必然是不同的。</li>
</ol>
<h1 id="写-React-的体验"><a href="#写-React-的体验" class="headerlink" title="写 React 的体验"></a>写 React 的体验</h1><p>之前写惯了 Vue，在写 React 的时候给我几个感受：</p>
<ul>
<li>相比于 Vue 提供的一整套语法糖来实现渲染，React 的对渲染细节的控制能力比 Vue 好，更自由。</li>
<li>相比于 Vue 的类 HTML 写法让人看着很自然很舒服，React 的函数式编程让整体代码显得有些乱，应该是我还不习惯函数式编程的缘故把。</li>
<li>React 的社区真的很活跃，所以相关框架和库非常多。就我接手的两个 React 项目分别用到了 dva、umi、mobx 等不同的框架和库，而 Vue 大多数都是用的 Vue 提供的全家桶来进行开发。</li>
<li>ant design 真的很棒，据说有一个团队在维护它，相对而言 Vue 的几个组件库的功能数量和组件质量上就稍微差一些了。</li>
<li>在 React 中用到了像 class、注解等很多新特性，感觉很高级。Vue 项目并没有加这些新特性。由于 React 的自由度，社区把各种新语法都在 React 上玩起来了。</li>
<li>虽然大家各种对比前端三大框架，其实底层逻辑还是 JavaScript、HTML 和 CSS。我最近学习的 this、箭头函数、class、原型、ES6特性等知识点对我上手 React 的确有很大的帮助。所以说万变不离其宗，学好基础和底层逻辑最重要。</li>
</ul>
<h1 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h1><ol>
<li>遇到新技术一定仔细阅读完文档，可以避免很多不必要的坑。比如我在写 React 项目的时候花了一天时间写了一个组件，结果回头一看 antd 里面有差不多一样的 demo，实现的还比我好。</li>
<li>解决类似问题的技术的技术逻辑必然也是类似的，通过类比联想的方式学习相似技术可以提高不少的效率。</li>
<li>遇到问题要仔细阅读文档、Google 查找，在确认没有答案之后再询问他人，随意的打断他人问一些低级问题是非常不礼貌、不专业的。</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>个人认为，如果前端基础足够扎实，上手这些框架都并非难事，只要熟悉了框架以及相关库的用法就可以得心应手了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2019/02/14/type/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/type/" class="post-title-link" itemprop="url">JavaScript 类型全知道</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-14T00:00:00+08:00">2019-02-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>今天来聊聊 JavaScript 的类型。</p>
</blockquote>
<h1 id="JavaScript-的七大基本类型"><a href="#JavaScript-的七大基本类型" class="headerlink" title="JavaScript 的七大基本类型"></a>JavaScript 的七大基本类型</h1><ul>
<li>undefined 未定义</li>
<li>null 空值</li>
<li>boolean 布尔值</li>
<li>string 字符串</li>
<li>number 数字</li>
<li>object 对象</li>
<li>symbol 符号（ES6）</li>
</ul>
<p>怎么知道是有这么七个值呢，使用 typeof 运算符来查看。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-43607c1c53f7dca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="typeof"></p>
<p>上图中，大多数都如我们想的那样，但是有两个特例：</p>
<ol>
<li>可以看到 <code>typeof null</code> 理论上应该返回 <code>&#39;null&#39;</code> 但却返回的是 <code>&#39;object&#39;</code>，这是一个存在20多年由来已久的bug，所以要判断对象是否为 null 时需要注意。</li>
<li>当我们打印 <code>typeof function() {}</code> 的时候返回的类型是 <code>&#39;function&#39;</code>，是不是说明 function 也是基本类型呢？但其实 function 是 object 的子集，下面说引用类型的时候会提到。</li>
</ol>
<h1 id="null、undefined-和-undeclared"><a href="#null、undefined-和-undeclared" class="headerlink" title="null、undefined 和 undeclared"></a>null、undefined 和 undeclared</h1><p>在 JavaScript 的类型中有三种表示变量“不存在”的方式，null、undefined 和 undeclared。那么它们的区别是什么呢？看代码~</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-354f1c86c7c9d36e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种空"></p>
<ul>
<li>我们定义了变量 a 却没有给他赋值，所以 a 就是 undefined</li>
<li>我们没有定义变量 b，所以报错 b is not defined，我们称之为 undeclared。注意这和 undefined 是有区别的。</li>
<li>我们定义了变量 c 并给他赋值 null，所以 b 就是 null</li>
</ul>
<p>小结下：undefined 是定义了变量却没有赋值；undeclared 是没有定义变量更没有赋值，会报错；null 是定义了变量并且赋值空值 null。</p>
<h1 id="JavaScript-中的那些引用类型"><a href="#JavaScript-中的那些引用类型" class="headerlink" title="JavaScript 中的那些引用类型"></a>JavaScript 中的那些引用类型</h1><p>所有的引用类型都是 Object。我猜测由于在 JavaScript 中对于 Object 的访问是引用形式的，所以称之为引用类型。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 是一个函数，它可以用于创建对象，也可以用它带的 API 方法操作对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object API</span></span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">var</span> object2 = <span class="built_in">Object</span>.freeze(object1);</span><br></pre></td></tr></table></figure>
<p>为什么可以使用这些 API？因为在 Object 函数的原型（关于原型可以看之前的文章）中有定义这些 API 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-2ecc22f6b5162ed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="api 方法在这里"></p>
<p>其他更多的 Object API 可以查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">Object - JavaScript | MDN</a>。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>同样的，Array 函数用于创建数组和提供操作数组的 API。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create array</span></span><br><span class="line"><span class="keyword">var</span> arr1 = []</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// api</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr1);</span><br><span class="line">arr1.push(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>同样的，推荐查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array - JavaScript | MDN</a> 获取更多 API 信息。</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Data 用于创建时间对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br></pre></td></tr></table></figure>
<p>Date 函数通过传递不同的参数在生产不同的时间对象，参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date - JavaScript | MDN</a>。</p>
<p>注：在 ES6 中可以通过静态方法 Date.now() 来获取当前时间。</p>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/\w+/</span>; </span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\w+'</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Function 构造函数 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个 Function 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Function</span>( <span class="string">"a"</span>, <span class="string">"return a * 2;"</span> ); <span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a * <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">a</span>) </span>&#123; <span class="keyword">return</span> a * <span class="number">2</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="包装器对象（Boolean、String-和-Number）"><a href="#包装器对象（Boolean、String-和-Number）" class="headerlink" title="包装器对象（Boolean、String 和 Number）"></a>包装器对象（Boolean、String 和 Number）</h2><blockquote>
<p>Boolean、String 和 Number 分别是基本类型 boolean、string 和 number 的包装器对象，有很多共性，所以就拿来一起讲了。</p>
</blockquote>
<h3 id="创建值"><a href="#创建值" class="headerlink" title="创建值"></a>创建值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> bool2 = <span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="built_in">String</span>(<span class="string">'hello world'</span>) <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="number">100</span>) <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
<p>可以看到，第二种创建方式非常的画蛇添足，但是这种写法可以有别的用处。</p>
<h3 id="自动包装"><a href="#自动包装" class="headerlink" title="自动包装"></a>自动包装</h3><p>上面我们定义了三个不同基本类型的变量，这几个变量后面可以加一些方法来进行操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool.toString();</span><br><span class="line">str.split(<span class="string">' '</span>)</span><br><span class="line">num..toFixed(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>为什么明明基本类型没有这些属性和方法却可以使用呢？<br>这就要提到这三个基本类型的自动包装特性了。即虽然这三个基本类型没有属性，但是当我们调用其属性和函数时，会自动包装成相应的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(bool).toString()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(str).split(<span class="string">' '</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(num).toFixed(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>可以看下 String 的原型中的确包含了 string 类型用到的所有的属性和方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-1e612c6730b31699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="string"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>对象包装器另外一个作用 —— 强制类型转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>); <span class="comment">// 'null'</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">12138</span>); <span class="comment">// '12138'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">"123"</span>)  <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">""</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>直接使用包装器函数就可以对值进行强制类型转换行为。</p>
<h2 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h2><p>Global 表示全局对象，具体的内容暂时没有找到，先贴一段网上的解释：</p>
<blockquote>
<p>《JavaScript高级程序设计》中谈到，global对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。从某种意义上讲，它是一个终极的“兜底儿对象”，换句话说呢，就是不属于任何其他对象的属性和方法，最终都是它的属性和方法。我理解为，这个global对象呢，就是整个JS的“老祖宗”，找不到归属的那些“子子孙孙”都可以到它这里来认祖归宗。所有在全局作用域中定义的属性和函数，都是global对象的属性和方法，比如isNaN()、parseInt()以及parseFloat()等，实际都是它的方法；还有就是常见的一些特殊值，如：NaN、undefined等都是它的属性，以及一些构造函数Object、Array等也都是它的方法。总之，记住一点：global对象就是“老祖宗”，所有找不到归属的就都是它的。</p>
</blockquote>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math 是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。举几个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>);     <span class="comment">// 取绝对值 1</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//  取最大值 20</span></span><br><span class="line"><span class="built_in">Math</span>.random(); <span class="comment">// 取随机数</span></span><br></pre></td></tr></table></figure>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 函数是 ES6 添加的，用于表示有唯一性的特殊值。创建方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'this is a symbol'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Error 函数用于创建错误对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I was created using a function call!'</span>)</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="built_in">Error</span>(<span class="string">'I was created using a function call!'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文先是介绍了七大基本类型，之后有简单介绍了 JavaScript 中的引用类型。主要想达到归纳整理的作用，让大家知道都有哪些类型，而具体使用中则强烈推荐查阅 <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a> 来使用各种方法和属性。</p>
<p>希望本文对你有所帮助~明天聊聊我最近从 Vue 转 React 项目的一些体会，明天见！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2019/02/13/behavior/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/13/behavior/" class="post-title-link" itemprop="url">聊聊对象行为委托</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-13T00:00:00+08:00">2019-02-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>昨天我们聊到了对象的原型，知道了有 new 和 Object.create() 两种操作原型的方式。今天我们来对比下使用这两种方式进行面向对象编程的特点。</p>
</blockquote>
<h1 id="使用-new-关键字写面向类"><a href="#使用-new-关键字写面向类" class="headerlink" title="使用 new 关键字写面向类"></a>使用 new 关键字写面向类</h1><p>先来一段面向类的代码实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    Foo.call(<span class="keyword">this</span>, who);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>
<p>当然也可以用 ES6 的 class 语法糖。class 的出现避免了在函数的 <code>prototype</code> 上添加属性的奇怪的行为。</p>
<h1 id="混乱不堪的原型关系"><a href="#混乱不堪的原型关系" class="headerlink" title="混乱不堪的原型关系"></a>混乱不堪的原型关系</h1><p>无论是 function 还是 class，其背后还是逃不开对于 prototype 的操作。而原型中各种关系令人头疼。下面是这段代码的关系图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-b78fe4bbd7d6532a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型关系"></p>
<p>抛开函数与 Function 和 Object 的关系，我们来捋一捋代码中的逻辑。</p>
<ol>
<li>Foo 函数的 prototype 上创建了函数 identify</li>
<li>Foo 函数的 prototype 引用了 Object 的原型（原型链理论）</li>
<li>Bar 函数 prototype 引用了以 Foo 的 prototype 为原型创建的对象</li>
<li>Bar 函数的 prototype 上创建了函数 speak</li>
<li>以 Bar 为构造器分别 new 了两个对象 b1 和 b2，b1 和 b2 的原型引用了 Bar 函数的 prototype</li>
<li>由于 Bar 进行了修改原型的操作，所以没有 constructor 函数。</li>
<li>所以根据原型链理论，Bar 的 prototype 和 b1、b2 的 constructor 都指向了 Foo 函数的 constructor。</li>
</ol>
<p>就这么个逻辑（这还没有包括函数与对象之前的关系），我表示我讨厌在 prototype 上去添加属性，这显得非常乱。</p>
<p>最后输出的 b1 对象的原型结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-1cd13125458907a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型结构"></p>
<h1 id="行为委托闪亮登场"><a href="#行为委托闪亮登场" class="headerlink" title="行为委托闪亮登场"></a>行为委托闪亮登场</h1><p>可以看到上面的写法导致指向非常混乱，实际上我们并不需要了解这么多逻辑。下面介绍一种方式完全不管 prototype 真正面向对象的写法 —— 行为委托。</p>
<p>就拿上面的例子来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foo = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params">who</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.me = who;</span><br><span class="line">    &#125;,</span><br><span class="line">    identify: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar = <span class="built_in">Object</span>.create(Foo);</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b1.init(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b2.init(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>
<p>其中的关键就是完全使用对象来写面向对象编程，而避免使用 new 一个构造器的写法。这里我们也来理一理逻辑：</p>
<ol>
<li>创建 Foo 对象，它包含 init 和 identify 两个函数属性。</li>
<li>创建 Bar 对象原型继承 Foo 对象。</li>
<li>在 Bar 对象上添加 speak 方法。</li>
<li>创建 b1 和 b2 对象原型继承 Bar 对象。</li>
<li>使用原型链上的 init 函数为 b1 和 b2 对象传入数据。</li>
<li>通过原型链调用 speak 函数。</li>
</ol>
<p>这种写法的原型关系图就简单了很多：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-bdc4c082cbe29864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型关系"></p>
<p>可以看到与第一中方法比少了函数构造器，少了函数构造器就没了 constructor 和 prototype。完全通过对象与对象之间的原型继承引用关系来实现面向对象的编程思想。</p>
<p>最后看下输出的 b1 对象的原型结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-20caa15116450797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型结构"></p>
<h1 id="行为委托的好处"><a href="#行为委托的好处" class="headerlink" title="行为委托的好处"></a>行为委托的好处</h1><ul>
<li>行为委托避免使用 new 构造器形式来实现面向对象，减少了大量构造器所带出的复杂关系。</li>
<li>行为委托只使用对象之间的原型继承关系，让整个代码逻辑变得非常清晰。</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这里介绍了行为委托这一种面向对象的设计思想，它让面向对象编程变得更加简洁、更加自然。</p>
<p>当然，这只是一种设计方式。如果执意要用 new 写法来写面向对象编程当然没有问题，推荐使用 class 语法糖，它可以将操作 prototype 的行为给隐藏起来，这使得代码更像 Java（引用对象的特性并未改变，所以只是看着像），从而让代码更好理解。</p>
<p>赶快去试试行为委托吧，我认为它是种很适合 JavaScript 的设计模式。</p>
<p>明天我们聊聊 JavaScript 的类型~</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2019/02/12/prototype/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/12/prototype/" class="post-title-link" itemprop="url">聊聊 JavaScript 的原型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-02-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-12T00:00:00+08:00">2019-02-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>JavaScript 中的原型也是一个非常让人头疼的东西，很多前端同学对此也是一知半解，比如我。今天我们就好好捋一捋这个原型。</p>
</blockquote>
<h1 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h1><p>下面就是创建对象的几种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">123</span>,</span><br><span class="line">    b: <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o1.b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">33</span></span><br><span class="line">    <span class="keyword">this</span>.b = <span class="string">'hello o2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> fun2()</span><br><span class="line"><span class="built_in">console</span>.log(o2.b)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">365</span></span><br><span class="line">        <span class="keyword">this</span>.b = <span class="string">'hello class'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> Fun3()</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>
<p>有人说这是三种创建方式，但是我认为其实是两种创建方式（因为 class 语法糖的本质还是 function）：<strong>直接定义对象</strong>和<strong>使用 new 关键词构造对象</strong>。</p>
<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><p>当我们创建了一个对象之后，就产生了原型（<code>Object.create(null)</code> 是特例）。</p>
<h2 id="prototype-和-proto-的区别"><a href="#prototype-和-proto-的区别" class="headerlink" title="prototype 和 __proto__ 的区别"></a>prototype 和 <code>__proto__</code> 的区别</h2><p><code>__proto__</code> 是一个非正式的属性，很多环境中不支持该属性。它指向当前对象的原型。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-1002cf3d69276266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="__proto__"></p>
<p>上面的代码是一段原型继承，可以看到对象 obj1 继承了对象 obj，所以 obj1 的 <code>__proto__</code> 就指向了 obj，而 obj 的 <code>__proto__</code> 则指向了 Object。所有对象的原型链最终都将指向 Object。</p>
<p>而关于 prototype 我摘录了一段话：</p>
<blockquote>
<p>当你创建函数时，JS 会为这个函数自动添加 <code>prototype</code> 属性，值是一个有 constructor 属性的对象。而一旦你把这个函数当作构造函数（<code>constructor</code>）调用（即通过<code>new</code>关键字调用），那么 JS 就会帮你创建该构造函数的实例，实例继承构造函数 <code>prototype</code> 的所有属性和方法。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-c600260dc91c2314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prototype"></p>
<p>可以看到，对象 bar 的 <code>__proto__</code> 属性指向了函数 func 的 <code>prototype</code>。</p>
<p>总结下，<code>__proto__</code> 指向原型，而 <code>prototype</code> 是函数独有且构造的对象原型指向 <code>prototype</code>。</p>
<h2 id="理解原型链"><a href="#理解原型链" class="headerlink" title="理解原型链"></a>理解原型链</h2><p>每个对象都是原型，而对象之间是可以继承的。所以就产生了原型链。看图说话：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-aa7441f2c85bb6f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链"></p>
<p>很好理解了，我们创建了四个对象逐层进行原型继承。最后打印 obj3 对象可以看到 <code>obj3 -&gt; obj2 -&gt; obj1 -&gt; obj -&gt; Object</code> 这就是原型链。</p>
<p>如果我要在 obj3 对象上访问 a 属性，那么 JavaScript 就会顺着原型链逐层往下找，最终在 obj 对象上找到了a 属性，这就是原型链查找数据的方式。如果找到 Object 也没有找到属性就返回 <code>undefined</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-07ac0815c99f5d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链查找"></p>
<h1 id="为对象指定原型的两种方式"><a href="#为对象指定原型的两种方式" class="headerlink" title="为对象指定原型的两种方式"></a>为对象指定原型的两种方式</h1><p>那么如何为对象添加原型呢？</p>
<h2 id="1-new-关键字"><a href="#1-new-关键字" class="headerlink" title="1. new 关键字"></a>1. new 关键字</h2><p>第一种就是通过构造器的方式来创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">11</span></span><br><span class="line">    <span class="keyword">this</span>.b = <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.c = <span class="number">33</span></span><br><span class="line">Foo.prototype.func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f))</span><br></pre></td></tr></table></figure>
<p>当然，不得不说的是 ES6 的 class 语法糖写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">11</span></span><br><span class="line">        <span class="keyword">this</span>.b = <span class="number">22</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo()</span><br></pre></td></tr></table></figure>
<p>两者其实是一样的效果，但是 class 写法更接近常规的类写法。（终于可以让 function 回归它原本的作用上了。）</p>
<h2 id="2-Object-create-obj-面向对象"><a href="#2-Object-create-obj-面向对象" class="headerlink" title="2. Object.create(obj) 面向对象"></a>2. Object.create(obj) 面向对象</h2><p>Object.create() 可以很好的实现原型继承行为，也能通过 Object API 来修改原型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">123</span>, <span class="attr">b</span>: <span class="number">456</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, &#123; <span class="attr">c</span>: <span class="number">789</span> &#125;)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">obj2.e = <span class="number">555</span></span><br></pre></td></tr></table></figure>
<p>代码输出结果如下图，的确实现了为对象指定原型的行为。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-b592d69f559248af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型继承和修改"></p>
<h1 id="引用流还是复制流？"><a href="#引用流还是复制流？" class="headerlink" title="引用流还是复制流？"></a>引用流还是复制流？</h1><p>使用 JavaScript 原型是特别要主义的一个点是：<strong>JavaScript 对于原型的继承是一种引用行为</strong>，即所引用的对象改变，继承对象的原型也会改变。</p>
<p>与之相反的，有些语言会使用复制的方式。即在原型继承时复制一份原型到当前对象，从此被复制的对象和复制对象再无瓜葛。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着 Object.create() 等一系列新 API 和 ES6 的 class 写法的出现，使用 function 作为构造器并使用 prototype 来修改原型的方式将逐渐被抛弃。但是由于历史原因这部分知识还是要理解其中原理的。</p>
<p>而 <code>__proto__</code> 属性是非正式属性，不适合在通用场景下使用。</p>
<p>而对于原型的写法，我认为有两种不错的处理方式：</p>
<blockquote>
<ol>
<li>完全使用 class 构造器写法来替代使用 function 构造器的写法来进行<strong>面向类</strong>的开发方式。</li>
<li>放弃原型写法，使用 Object 系列 API 进行<strong>面向对象</strong>的开发（行为委托就是这样的方式）。</li>
</ol>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>关于原型，先聊这么多。明天我们聊聊基于 Object API 来实现的面向对象模式 —— 行为委托，敬请期待。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2019/02/11/this/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/this/" class="post-title-link" itemprop="url">聊聊 JavaScript 的 this</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-02-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-11T00:00:00+08:00">2019-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript 中的 this 一直是比较让人头疼，也是面试特别容易问及的问题。下面就参照这《你不知道的 JavaScript》来学习下 this 这个神奇的东西。</p>
<h1 id="this-到底指向何处"><a href="#this-到底指向何处" class="headerlink" title="this 到底指向何处"></a>this 到底指向何处</h1><blockquote>
<p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>
</blockquote>
<p>所以，this 并不只是简单地指向函数或者对象自身。</p>
<h1 id="this-的四种绑定方式"><a href="#this-的四种绑定方式" class="headerlink" title="this 的四种绑定方式"></a>this 的四种绑定方式</h1><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>所谓的默认绑定就是 this 的默认绑定方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>严格模式下这种默认绑定形式不成立。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>隐式绑定是指 this 所在函数在有<strong>上下文</strong>的前提下的绑定，如 <code>obj.foo();</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>对象中的函数只是引用关系，即对象和函数存在于两个地方。所以在别的地方使用函数，与隐式绑定的对象就没有关系了。看下两个例子：</p>
<ol>
<li>其中 <code>var myFoo = obj.foo</code> 的 myFoo 变量引用的是 foo() 函数，与 obj 并无关系。所以 myFoo 的执行函数行为就变成了默认绑定，打印结果为 1。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFoo = obj.foo</span><br><span class="line">myFoo(); <span class="comment">// 默认绑定，值为 1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在回调函数中其实也会出现 this 绑定丢失的情况，回调函数 obj.foo 引用的是 foo 函数，与 obj 对象并无关系。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(obj.foo, <span class="number">300</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>显式绑定就是指使用 call、apply、bind 来指定某个上下文进行绑定，它们的一个作用就只为函数硬绑定一个上下文对象。</p>
<p>之前的回调函数使用 bind 进行修改后打印出了我们 obj 对象中的 a 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(obj.foo.bind(obj), <span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p>call 和 apply 也是类似的，通过对函数指定上下文来进行硬绑定，且硬绑定只能绑定一次。</p>
<blockquote>
<p><code>call()</code> 方法的作用和 <code>apply()</code> 方法类似，区别就是 <code>call()</code> 方法接受的是参数列表，而 <code>apply()</code> 方法接受的是一个参数数组。</p>
</blockquote>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>new 关键字创建对象的过程其实也是一个绑定上下文的过程，所以使用 new 创建的对象的 this 也要格外注意。</p>
<blockquote>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this 。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>可以看到 new 行为的第三步就是进行 this 绑定，我们也可以从代码看到 new 行为的确有绑定 this 的能力。</p>
<h2 id="this-四种绑定方式排序"><a href="#this-四种绑定方式排序" class="headerlink" title="this 四种绑定方式排序"></a>this 四种绑定方式排序</h2><p>既然四种绑定都能够改变 this 的指向，那么这四种绑定的优先级是怎样的呢？结论是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</span><br></pre></td></tr></table></figure>
<p>虽然很少会出现多个场景绑定一个 this 的情况，但是知道下也能以防万一。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>关于 this 最后要说的就是 ES6 的箭头函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 this 在此法上继承自 foo()</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>它完全等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// lexical capture of this</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(self.a);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>关于箭头函数只要记住 <code>var self = this;</code> 就够了。</p>
<p>它其实是通过词法作用域保存当前 this 上下文传递给回调函数。本质上是抛弃了 this 原有的机制。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我们从四种常见 this 绑定方式和箭头函数这两个角度系统的学习了 this 绑定的知识点，相信之后你再也不怕 this 相关的知识点了！</p>
<p>本文还有很多可以改进的地方，如有任何意见和问题，欢迎留言指出。谢谢~</p>
<h1 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h1><ul>
<li>你不知道的 JavaScript （上册）</li>
<li><a href="https://juejin.im/entry/57c25064d342d3006b216070" target="_blank" rel="noopener">Know this, use this! (总结 this 的常见用法)</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2019/01/12/scope/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/12/scope/" class="post-title-link" itemprop="url">JavaScript 作用域详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-12T00:00:00+08:00">2019-01-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文首发于<a href="https://zhuanlan.zhihu.com/c_1045249924572676096" target="_blank" rel="noopener">贝壳社区FE</a>专栏，欢迎关注！</p>
</blockquote>
<h1 id="一、什么是作用域"><a href="#一、什么是作用域" class="headerlink" title="一、什么是作用域"></a>一、什么是作用域</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><blockquote>
<ul>
<li><strong>分词/词法分析(Tokenizing/Lexing)</strong><br>这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代 码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。</li>
<li><strong>解析/语法分析(Parsing)</strong><br>这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。<br>var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下 来是一个叫作 Identifier(它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子 节点。</li>
<li><strong>代码生成</strong><br>将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。<br>抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指 令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。</li>
</ul>
</blockquote>
<p>简而言之：</p>
<ol>
<li>将代码以词为单位拆分成一个个词法单元。</li>
<li>解析词法单元转换成 AST 语法树。</li>
<li>生成机器指令。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-5b4473c428c6d144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译过程"></p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>整个编译过程有三个角色需要登场：</p>
<ul>
<li><strong>引擎</strong> 负责整个 JavaScript 程序的编译及执行过程。</li>
<li><strong>编译器</strong> 负责语法分析及既期代码生成。</li>
<li><strong>作用域</strong> 负责收集并维护所有声明的变量组成的一系列查询。</li>
</ul>
<p>那么整个 <code>var a = 2;</code> 的编译过程如下：</p>
<ul>
<li><strong>编译器</strong>拿到 <code>var a = 2;</code> 这段代码，进行语法分析。</li>
<li><strong>编译器</strong>分析到 <code>var a</code>，向<strong>作用域</strong>进行变量定义操作。<ul>
<li>如果<strong>作用域</strong>中已有 a 变量，直接通知<strong>编译器</strong>。</li>
<li>如果<strong>作用域中</strong>没有 a 变量，创建 a 变量并通知<strong>编译器</strong>。</li>
</ul>
</li>
<li><strong>编译器</strong>收到通知，继续执行并将 <code>a = 2</code> 这段代码编译为机器语言传给<strong>引擎</strong>。</li>
<li><strong>引擎</strong>拿到 <code>a = 2</code> 向<strong>作用域</strong>中去查找 a 变量，准备赋值操作。<ul>
<li>如果 a 所在作用域下有 a 变量，<strong>作用域</strong>直接通知<strong>引擎</strong>。</li>
<li>如果 a 所在作用域下没有 a 变量，则不断向外部作用域查找 a 变量。<ul>
<li>在外部作用域找到 a 变量，<strong>作用域</strong>通知<strong>引擎</strong>。</li>
<li>在外部作用域找 a 变量直到全局作用域下也没有找到，<strong>作用域</strong>通知<strong>引擎</strong>未找到 a 变量。</li>
</ul>
</li>
</ul>
</li>
<li><strong>引擎</strong>收到通知<ul>
<li>如果找到 a 变量，<strong>引擎</strong>在<strong>作用域</strong>内对变量 a 赋值。</li>
<li>如果没有找到 a 变量，<strong>引擎</strong>发出 <code>Refence Error</code> 错误。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-22a485401f80754d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"></p>
<h2 id="作用域的好处"><a href="#作用域的好处" class="headerlink" title="作用域的好处"></a>作用域的好处</h2><ul>
<li>安全性 —— 变量和函数可以定义在最小作用域下。</li>
<li>减少命名冲突 —— 作用域帮我们较少命名冲突发生的概率。</li>
<li>代码复用性 —— 好的局部作用域可以提升代码的复用性。</li>
</ul>
<h1 id="二、LHS-与-RHS"><a href="#二、LHS-与-RHS" class="headerlink" title="二、LHS 与 RHS"></a>二、LHS 与 RHS</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我对于 LHS 和 RHS 的理解是：所有赋值操作都是 LHS，如 <code>a = 2;</code>；而所有的取值操作都是 RHS，如 <code>console.log(a);</code>。</p>
<blockquote>
<p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。 —— 《你不知道的 JavaScript》</p>
</blockquote>
<h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><p>在非严格模式下，当变量 a 未被定义，像 <code>console.log(a)</code> 这样的RHS 查找会报 <code>ReferenceError</code> 的错误，而像 <code>b = 2</code> 这样的 LHS 查找会在全局作用域下创建变量并进行赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// type: RHS, output: ReferenceError</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">// type: LHS, output: 2</span></span><br></pre></td></tr></table></figure>
<p>而在严格模式下，LHS 和 RHS 的效果是相同的，都会报 <code>ReferenceError</code>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在以上例子中有 3 次 RHS 和 1 次 LHS</p>
<ul>
<li>RHS <code>foo(2)</code> 查找 foo 函数。</li>
<li>LHS <code>foo(2)</code> 隐藏着 <code>a = 2</code> 赋值行为。</li>
<li>RHS <code>console.log(a)</code> 查找 console 对象</li>
<li>RHS <code>console.log(a)</code> 查找 a 变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>找出 3 次 LHS 4 次 RHS。</p>
<ul>
<li>RHS: <code>foo(2)</code> 查找 foo 函数。</li>
<li>LHS: <code>foo(2)</code> 隐藏有 <code>a = 2</code> 赋值行为。</li>
<li>LHS: <code>var c = foo(2)</code> 是赋值行为。</li>
<li>RHS: <code>var b = a</code> 查找 a 变量。</li>
<li>LHS: <code>var b = a</code> 是赋值行为。</li>
<li>RHS: <code>return a + b</code> 查找 a 变量。</li>
<li>RHS: <code>return a + b</code> 查找 b 变量。</li>
</ul>
<h1 id="三、词法作用域及欺骗词法"><a href="#三、词法作用域及欺骗词法" class="headerlink" title="三、词法作用域及欺骗词法"></a>三、词法作用域及欺骗词法</h1><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是指我们代码词法所表示的作用域。看下如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a, b, c );</span><br><span class="line">  &#125;</span><br><span class="line">  bar( b * <span class="number">3</span> ); </span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="number">2</span> ); <span class="comment">// 2, 4, 12</span></span><br></pre></td></tr></table></figure>
<p>这段代码的词法作用域如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-1641a475f9ce9427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="词法作用域"></p>
<p>其实就是我们在代码编写时所定义的作用域即词法作用域。</p>
<h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>当然也有不按词法规则来的写法，称为欺骗词法。</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>类似于 <code>eval()</code> 方法会将字符串解析成 JS 语言的执行。它将破坏词法作用域的规则。如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'var a = 3'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with 这个冷门的关键词通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单调乏味的重复 "obj" </span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 简单的快捷方式 </span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  b = <span class="number">4</span>;</span><br><span class="line">  c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种赋值方式看似等价。但如果赋值目标是 obj 对象中没有的变量，两种赋值效果是不同的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.d = <span class="number">11</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, b:2, c:3, d: 11 &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  d = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, b:2, c:3 &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>可以看到在 with 函数中的对于变量 d 的赋值行为（LHS）是定义在了 window 对象上的。</p>
<h1 id="四、函数作用域和块作用域"><a href="#四、函数作用域和块作用域" class="headerlink" title="四、函数作用域和块作用域"></a>四、函数作用域和块作用域</h1><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>通常情况下，函数内的变量无法在函数外调用。即变量存在于函数作用域下，所以函数作用域起到了局部变量或者变量隐藏的作用。如下例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>以上写法将 foo 方法中的 a 变量隐藏了起来。不过也产生了一个问题 —— 全局作用域下多了一个 foo 函数变量。解决这种污染的方式是立即执行函数（IIFE），我们将上面的代码进行改造：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>这种写法就可以将 foo 函数变量也隐藏起来，避免对全局作用域的濡染。</p>
<h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>块级作用域存在于 <code>if</code>, <code>for</code>, <code>while</code>, <code>{}</code> 等语法中，这些作用域中使用 var 定义的变量是不在这个作用域内的。</p>
<p>块作用域和函数定义域的区别在于：函数定义域隐藏函数内的变量，而块作用域隐藏块中的变量。举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数作用域，隐藏变量a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块作用域，隐藏变量 i</span></span><br><span class="line"><span class="comment">// 不隐藏变量 a （不是函数作用域）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<h3 id="with-与-try-catch"><a href="#with-与-try-catch" class="headerlink" title="with 与 try/catch"></a>with 与 try/catch</h3><p>with 和 catch 关键字都会创建块级作用域，因为他们创建的作用域在外部作用域中无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="literal">undefined</span>(); <span class="comment">// 执行一个非法操作来强制制造一个异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 能够正常执行! </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<h3 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h3><p>let 和 const 关键字可以将变量绑定到所在的任意作用域中。换句话说，<strong>let 和 const 为其声明的变量隐式地了所在的块作用域。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>可见 const 和 let 能够保证变量隐藏在所在作用域中。</p>
<h3 id="var-与-let-的差异"><a href="#var-与-let-的差异" class="headerlink" title="var 与 let 的差异"></a>var 与 let 的差异</h3><p>由于 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>而 ES6 所提出的 let 和 const 为 JavaScript 带来了块作用域解决了这个问题。</p>
<p>下面列出4点 var 与 let 的差异之处：</p>
<ol>
<li>let 不存在变量提升。(var 的变量提升下文有提及)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>let 在块作用域内定义了变量后不受外部作用域变量影响。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ol>
<li>不允许重复申明。</li>
<li>最大的不同是在于 let 作用域块作用域，而 var 只作用域函数作用域和全局作用域。</li>
</ol>
<h1 id="五、变量提升"><a href="#五、变量提升" class="headerlink" title="五、变量提升"></a>五、变量提升</h1><p>在使用 var 定义变量和使用 function 定义函数时，会出现变量提升的情况。</p>
<h2 id="编译顺序"><a href="#编译顺序" class="headerlink" title="编译顺序"></a>编译顺序</h2><p>看几个例子来理解下变量提升：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="comment">// JavaScript 的处理逻辑</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; </span><br><span class="line"><span class="comment">// JavaScript 的处理逻辑</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined </span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JavaScript 的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined </span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><strong>为什么呢？</strong>回忆一下上文说到的编译过程就能理解了。看图！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1987062-22a485401f80754d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图"></p>
<p>可以看到编译器会将变量都定义到作用域中，然后再编译代码给引擎去执行代码命令。<strong>即 <code>var  a = 2；</code> 是被拆开执行的且 <code>var a</code> 变量会提前被定义。</strong></p>
<p>再来看一个不靠谱的函数定义方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// "b"</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果与《你不知道的 JavaScript》中的有所不同，在 node v10.5.0 中输出的是 <code>TypeError</code> 而非 <code>b</code>。这个差异有待考证。</p>
<h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>虽然函数和变量都会提升，但是编译器会先提升函数，再是变量。看如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时是函数定义，但是第二种是定义变量的形式，所以遵从函数优先原则，以上代码会变为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">// 无意义</span></span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="六、闭包"><a href="#六、闭包" class="headerlink" title="六、闭包"></a>六、闭包</h1><p>下面是人见人怕的闭包。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>当<strong>函数</strong>可以<strong>记住并访问所在的词法作用域</strong>时，就产生了闭包。<br>当<strong>函数</strong>可以<strong>记住并访问所在的词法作用域</strong>时，就产生了闭包。<br>当<strong>函数</strong>可以<strong>记住并访问所在的词法作用域</strong>时，就产生了闭包。<br>重要的定义说三遍！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"><span class="built_in">console</span>.log(baz()); <span class="comment">// 2 &lt;-- 这就是闭包</span></span><br></pre></td></tr></table></figure>
<p>按照我们对于函数作用域的理解，函数作用域外是无法获取函数作用域内的变量的。</p>
<p>但是通过闭包，函数作用域被持久保存，并且闭包函数可以访问到作用域下的变量。</p>
<p>下面再展示几个闭包便于理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  fn = baz; <span class="comment">// 将 baz 分配给全局变量 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">// &lt;-- 闭包!</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">// &lt;-- 闭包!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="string">"Hello, closure!"</span>);</span><br><span class="line"><span class="comment">// timer 持有 wait 函数作用域，所以是闭包。</span></span><br></pre></td></tr></table></figure>
<p>上面几个例子可以归纳下闭包的特性：</p>
<ol>
<li>闭包必定是函数。</li>
<li>函数可以在当前词法作用域外持有并访问词法作用域。</li>
</ol>
<p>就这么简单！按照这个定义其实所有的回调函数都属于是闭包。</p>
<h2 id="经典的循环面试题解析"><a href="#经典的循环面试题解析" class="headerlink" title="经典的循环面试题解析"></a>经典的循环面试题解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看以上写法最终输出的是什么呢？由于 var i = 0 是在全局作用域下，且没有任何地方存 i 的变化值，所以最终输出是 5 个 <code>6</code>。</p>
<p>解决方案有两种：</p>
<ol>
<li>使用闭包的持有作用域特性，为每一个 timer 函数封闭一个作用域保存当前的 i。</li>
<li>使用 let 块作用域封闭 for 循环中的作用域，保存当前的 i 值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块作用域写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li>《你不知道的 JavaScript（上）》</li>
<li><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">ECMAScript 6 入门</a></li>
<li><a href="https://codeburst.io/javascript-learn-understand-scope-f53d6592c726" target="_blank" rel="noopener">JavaScript: Learn &amp; Understand Scope</a></li>
<li><a href="https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/" target="_blank" rel="noopener">Everything you wanted to know about JavaScript scope</a></li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文旨在更方便和全面的理解作用域的相关知识，希望能对你有所帮助<br>JavaScript 的作用域知识不管是在面试中还是在实际工作中都是非常重要的。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2018/12/31/2018-sum/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/31/2018-sum/" class="post-title-link" itemprop="url">我的 2018 年终总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-31T00:00:00+08:00">2018-12-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:21:09" itemprop="dateModified" datetime="2019-02-16T01:21:09+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>以下总结仅限于个人认知，如有错误还请指正！</p>
</blockquote>
<h1 id="年度关键词"><a href="#年度关键词" class="headerlink" title="年度关键词"></a>年度关键词</h1><p><strong>2018 年是我快速提升认知、清晰认识自我的一年。</strong></p>
<p>在工作上，我对工作有了新的理解。</p>
<ol>
<li>理解了工作所处的系统是如何运作的；</li>
<li>理解了工作价值的本质；</li>
<li>理解了技术工作者能力提升的本质。</li>
</ol>
<p>在生活上，我确定了追寻幸福生活的人生目标。</p>
<ol>
<li>开始追寻生活的意义感；</li>
<li>用心体会和珍惜周围人际关系的情谊；</li>
<li>践行极简主义为自己减负。</li>
</ol>
<p>在个人成长上，我对于事物的思维方式和做事方法有了很大的更新。</p>
<ol>
<li>刻意锻炼自己开放性思维和独立思考的能力；</li>
<li>逐渐体会到知行合一的重要性；</li>
<li>践行以终为始地聪明学习方式。</li>
</ol>
<h1 id="对工作的新理解"><a href="#对工作的新理解" class="headerlink" title="对工作的新理解"></a>对工作的新理解</h1><h2 id="工作系统的运作方式"><a href="#工作系统的运作方式" class="headerlink" title="工作系统的运作方式"></a>工作系统的运作方式</h2><h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>我们工作的团队分工明确、各司其职，是一个非常棒的团队。在这段时间的接触和学习之后我大致理解了一下我们团队的运作方式。</p>
<p>从生产方式角度来说：<br>后端使用的是 Java 语言和 Sprint Boot 框架进行开发，使用 MySQL 来存储数据的。后端同学通过 Restful API 的形式与前端通信数据，并将接口文档写在公司 wiki 上便于联调。虽然技术上用的是框架，但是我发现后端同学对于业务的理解、逻辑的处理、大量数据的处理上面是非常复杂的。</p>
<p>测试同学我了解的更多一些。测试妹子们需要充分理解产品业务需求，写出非常完整严密的测试用例，使用代理抓包来监测各个端的网络通信情况；精通 shell 脚本并使用 Jenkins 来管理前后端项目的发布，或者使用命令行操作服务器；操作 MySQL 对数据库进行测试；写 Python、JavaScript 来进行一些自动化测试。还需要辛苦地人肉测试大量的数据；需要严密的测试思维。所以说测试妹子并不是只会对着手机和网页点点点这么简单的~</p>
<p>对于咱们前端，技术栈上使用了 Vue 和 React 两种，在框架上使用北京贝壳开发的 redskull2 脚手架来生成项目。项目包含前端项目和一个基于 koa 的中间 node 层项目。前端项目负责页面展示、数据通信等正常前端工作；node 层负责数据转发、单点登录验证等（其实可以做更多）。当开发完成后，我们会将前端项目打包成 JS Bundle 静态资源发布到 CDN 上，并将 node 项目部署到带有域名的服务器上。访问方式就是访问 node 端路由，由 node 端获取静态前端项目进行渲染。当然咱们也承接各种小程序的开发~这个流程大家都一样。</p>
<p>对于我们老大，我能看到的他主要负责团队文化建设、项目资源支持、战略方向制定这三件事。他那种看不见具体行动却时刻影响着整个团队进程的那种细雨润无声的能力真的非常厉害。</p>
<h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>在公司的理解上，我学到了公司的三个层级、八大部门理论。<br>三个层级分别是：执行、管理和决策。<br>八大部门分别是：服务、产品、研发、财务、人力、行政、销售、市场</p>
<h2 id="是什么为工作带来价值？"><a href="#是什么为工作带来价值？" class="headerlink" title="是什么为工作带来价值？"></a>是什么为工作带来价值？</h2><h3 id="万物皆产品，要用工匠精神打磨好产品"><a href="#万物皆产品，要用工匠精神打磨好产品" class="headerlink" title="万物皆产品，要用工匠精神打磨好产品"></a>万物皆产品，要用工匠精神打磨好产品</h3><p>对于我之前的努力，无论是之前的开发工作还是技术写作，其实都缺少一种产品意识。</p>
<p>在了解了一些产品知识之后，突然发现其实很多东西都可以看作是一款产品。无论是生活用品、各种软件、个人品牌，甚至是这篇文章其实都是一款产品。</p>
<p>而产品其实会带来一个价值问题，即<strong>你的产品能创造多少价值？目标群体用户是谁？传播方式有哪些？</strong>而想在职业发展和个人影响力上有大的提升，一款出色的代表作是必不可少的。如乔布斯和苹果、傅盛和360、微信和张小龙、ES6和阮一峰。</p>
<p>所以，万物皆产品。想要快速成长，就要用工匠精神打磨好每一款产品。</p>
<h3 id="产品价值是什么？"><a href="#产品价值是什么？" class="headerlink" title="产品价值是什么？"></a>产品价值是什么？</h3><p>我听过一些关于产品的看法：</p>
<ul>
<li>产品的诞生主要就是帮人偷懒；</li>
<li>产品必须要针对目标用户群体提供价值；</li>
<li>产品只有能够给用户省时间、省钱和更好的体验才是有价值的产品；</li>
<li>我自己私自加了一条：产品在能够利用现有资源解决痛点、满足需求时它就是有价值的。</li>
</ul>
<h3 id="工作价值-能力-资源-态度"><a href="#工作价值-能力-资源-态度" class="headerlink" title="工作价值 = 能力 + 资源 + 态度"></a>工作价值 = 能力 + 资源 + 态度</h3><p>这是一个衡量自身职场价值的公式。</p>
<p>能力即技术、沟通、管理等实际工作能力；资源是自身的人脉资源、影响力等；而态度就是成长性、忠诚度这些素质。</p>
<p>回想起我当时怀着一腔热血和不太符合要求的技术能力面试通过，想必就是态度帮助了我。</p>
<p>而我之后要做的，就是提升的就是工作能力，积累外在资源。</p>
<h2 id="技术的价值和能力提升"><a href="#技术的价值和能力提升" class="headerlink" title="技术的价值和能力提升"></a>技术的价值和能力提升</h2><h3 id="做时间的朋友"><a href="#做时间的朋友" class="headerlink" title="做时间的朋友"></a>做时间的朋友</h3><p>先讲个反面例子，我之前虽然自诩是技术爱好者，但是我所花在技术上的时间大多都是了解新技术、追寻热门技术。虽然花了很多时间学习，但却用处很小，可能学了10个技术，5个快速过时，3个不常用，1个非常重要但是精力不够了~</p>
<p>而像《CSS世界》的作者张鑫旭，坚持几年只专注于 CSS 这么一门看似简单枯燥的技术。看似很傻很浪费时间，但是他的坚持却让他变成了 CSS 方面的专家。事实也证明，虽然前端技术日新月异，但是其实底层的前端使用的还是 HTML、JavaScript 和 CSS，他通过坚守 CSS 提升了影响力和基础能力。无论前端技术再变，他对于 CSS 的精通都有有用的。</p>
<p>所以说，对于日新月异的技术，应该要学习能够长久存在的底层技术，做时间的朋友。</p>
<h3 id="技术认知四阶段"><a href="#技术认知四阶段" class="headerlink" title="技术认知四阶段"></a>技术认知四阶段</h3><p>下面是我最近思考如何学习更加长久存在的技术时偶得的，我认为技术层次分为四个层次：</p>
<ul>
<li>简单使用，能够使用常用技术 API 解决业务问题，需要大量翻阅技术文档。</li>
<li>精通用法，对技术的各种 API 了如指掌，工作效率显著提升。</li>
<li>基本原理，能清晰使用流程图画出整个技术结构、运行流程和设计思想，能快速定位底层问题，并查找解决。</li>
<li>融会贯通，熟悉技术到源码级别。能够直接出手解决底层问题，也能创造新的工具和解决方案。</li>
</ul>
<p>个人感觉优秀的程序员应该要努力将自己的层次到底第三阶段。</p>
<h3 id="学习技术的本质"><a href="#学习技术的本质" class="headerlink" title="学习技术的本质"></a>学习技术的本质</h3><p>既然说了学习技术要学长久存在的，学习技术要学到能够理解基本逻辑画出运行流程和设计思路。其实就是在说我们要学习一些底层的、本质的技术。</p>
<p>就拿我熟悉的前端做比方，前端可以学习的框架非常多，而工作中也经常会用到不同的工具，如果说我每个工具都学习到简单使用程度，那么每个工具都需要花时间去学习、查阅资料和实践。</p>
<p>但其实，很多的工具和框架都是有共性的。对于每一个使用的工具深刻的理解和研究是有价值的，因为这些逻辑和思想是可迁移的。</p>
<p>所以说，为什么技术大牛学习技术特别快？不是他们脑子有多么聪明，只是他们经历的多了，理解了技术的本质逻辑和思想，所以可以通过对已有知识的类比快速理解一项新的技术。</p>
<p>学习本质的技术，提炼逻辑和思想，学会类比和复用。</p>
<h1 id="如何追寻幸福人生"><a href="#如何追寻幸福人生" class="headerlink" title="如何追寻幸福人生"></a>如何追寻幸福人生</h1><p>今年看了几本关于幸福的书《活出生命的意义》、《你要如何衡量你的人生》、《象与骑象人》、《向死而生》、《极简主义》、《断舍离》，这让我对生活的意义感和幸福感更加的看重。</p>
<h2 id="做有意义的事"><a href="#做有意义的事" class="headerlink" title="做有意义的事"></a>做有意义的事</h2><p>不论是《活出生命的意义》还是《肖生克的救赎》里都提到了一点，<strong>能够在艰难困苦中生存下去的人必然会给自己找一些有意义的事情去坚持。</strong>像前面两个例子里的主人公使用写作和雕刻来保持生活的意义感。</p>
<p>心理学上有一种病叫做神经性官能症，就是指在内心的空虚感和对现实世界的虚无感的煎熬下，导致患上像抑郁这类疾病。而治疗神经性官能症的最佳方案就是快速找到一些有意义的事情，哪怕只是做个手工活、参加公一项益活动、从事一项带来幸福感的工作等。</p>
<p>像我其实对自己的现状感觉挺幸福的，工作内容就是我喜欢做的事情，常常能在工作中产生心流。而工作内容也能够被周围环境所认可。在家里玩游戏和写作是我喜欢干的事情，写作能带给我充实感和意义感，而游戏这个不好说，但起码它也能给我带来心流。所以总体来说我还是很充实的。</p>
<p>萧伯纳说过：很多人过得不快乐，因为他们有太多时间去想自己是不是幸福。</p>
<p>所以幸福其实很简单，<strong>找到几件些让自己感觉充实和幸福的事情，并立即行动起来。</strong></p>
<h2 id="珍惜身边的关系"><a href="#珍惜身边的关系" class="headerlink" title="珍惜身边的关系"></a>珍惜身边的关系</h2><p>在李开复老师的《向死而生》中，当他知道自己身患重病时，才发现自己最求的不断扩大影响力来改变世界都是五彩泡沫，他在查出患了癌症之后在微博上感叹：癌症面前，人人平等。不管是有钱有权有名，最终都无足轻重。那一刻他唯一想到的就是陪伴家人、见见挚友。</p>
<p>自此以后，他也不再以改变世界为目标、效率至上。他变得慢下来，花更多时间陪伴老母亲、妻子和两个女儿，拜访好友。甚至会与自己相遇的每一个有缘人交谈。</p>
<p>年末的时候看了一部叫《幸福一家人》的电视剧，也让我非常感动。它的主题曲中有这么一句：</p>
<blockquote>
<p>曾以为，理想才是唯一。我忙着去追寻，忘了身后风景。</p>
</blockquote>
<p>所以，我一直要警示自己：<strong>为了梦想而努力的同时，一定也要珍惜身边的人，慢下来用心的陪伴。</strong>其实良好的人际关系也是幸福的关键因素。</p>
<h2 id="极简生活"><a href="#极简生活" class="headerlink" title="极简生活"></a>极简生活</h2><p>另外一个对生活的感悟就是做减法。</p>
<p>西方谚语说：“最富有的人不是拥有最多，而是需求最少。”吴军老师在他的《谷歌方法论》中也不断强调做减法的重要性。我们老大也一再提醒我要做减法。今年我也看了《断舍离》和《极简》这两本书。</p>
<p>但人总是有一种想拥有更多的本能欲望和一种道理都懂但不被生活教训一下就不能理解的天性。今年，自己就胸怀壮志的买了大量的书、定了宏大的目标、买了好几个专栏、想学习各种技术，但结果是什么呢？</p>
<p>结果就是将自己累个半死；承担着巨大的心理负担和压力；想学的太多就必然学不深。</p>
<p>我们老大有句话非常有哲理：“多就是少，少就是多。手里想抓的沙子越多流失的越快。”</p>
<p>我现在对于看书和学习的态度有很大变化，只有能够解决当下问题的知识才去学习并立即进行实践。那些可能会用到的很有用的知识其实都是妄念。就像软件开发，实现一个功能可以选的技术类型和方案有各式各样，但是最终让产品产生价值的必然只是当前在使用的技术。程序员并不需要将所有可用技术全部精通才能做出好产品来。</p>
<p>所以要不断给工作、生活和物品都做减法。减少大量妄念所带来的内耗和压力，专注的去做真正更有价值的事情。</p>
<h1 id="思维方式和做事方法的探寻"><a href="#思维方式和做事方法的探寻" class="headerlink" title="思维方式和做事方法的探寻"></a>思维方式和做事方法的探寻</h1><h2 id="思维开放，独立思考"><a href="#思维开放，独立思考" class="headerlink" title="思维开放，独立思考"></a>思维开放，独立思考</h2><h3 id="理解现实规律"><a href="#理解现实规律" class="headerlink" title="理解现实规律"></a>理解现实规律</h3><p>这是从《原则》一书中学到的：我们无法预测未来，我们能做的就是观察这个世界，理解现实世界的运行规律和原理，去总结出一条条原则，并依照原则行事。</p>
<h3 id="保持开放和谦逊的头脑"><a href="#保持开放和谦逊的头脑" class="headerlink" title="保持开放和谦逊的头脑"></a>保持开放和谦逊的头脑</h3><p>人总是有两个自我的 —— 情绪自我和理性自我。情绪自我会在面对冲突时激发战斗和逃避的本能，且情绪自我的力量远大于理性自我。所以面对外界各种不同信息的涌入，必须要让自己保持开放的头脑和谦逊的态度去倾听，在感受到情绪来临时不要妄下结论。</p>
<p>不要被情绪抑制理性的思考，训练自己的拥有开放和谦逊心态。这里也推荐一种控制情绪的方法 —— 正念冥想。亲测简单可行见效快~</p>
<h3 id="独立思考"><a href="#独立思考" class="headerlink" title="独立思考"></a>独立思考</h3><p>或许是因为十几年的中国式教育让我适应了别人说什么就去虚心接受的习惯。很少思考收到的信息中的问题、弊端和漏洞。</p>
<p>我体会比较深的一点在于项目评审会上，当产品描述完它的方案我，给我的感觉就是完美无瑕、逻辑严密、无可挑剔。但是其他同事总能一针见血的提出一些建设性的问题和建议。我自己的感觉是我特别同理心的顺着产品的思维往下走，顺着他的思路走入了他的思维模式中。</p>
<p>当然，我也学到了一些解决方法，就是提前预习资料，独立思考。</p>
<p>但是在独立思考这一点上，还是需要继续加强。建立起自己的一套思考模式，更好地分辨信息的对错优劣。</p>
<h2 id="知行合一"><a href="#知行合一" class="headerlink" title="知行合一"></a>知行合一</h2><h3 id="积极学习认知"><a href="#积极学习认知" class="headerlink" title="积极学习认知"></a>积极学习认知</h3><p>2018 年我看了 25 本书，听了 2 个得到专栏和 100 多篇书评，最大的收获就是在认知方面的提升。看到了很多之前从未想过的事情，也给自己带来了巨大的正能量。</p>
<p>所以，2019 年我还是要坚持看书，提升认知和眼界。看书真的是非常好的自我提升的方式，有人提过这么一个逻辑：<strong>从古至今，牛人没有几个是不看书的。</strong>逻辑虽不严密，但大体上没毛病~</p>
<h3 id="用行动理解认知"><a href="#用行动理解认知" class="headerlink" title="用行动理解认知"></a>用行动理解认知</h3><p>在看了大量的书之后，自己犯了两个错误。一是感受到认知的提升后感觉自己与别人之间有不同，产生了优越感。二是认知提升之后，心变得很大。感觉自己什么都懂，自己能够快速成为成功人士。但这一切都是错觉。</p>
<p>知道了前人的经验和知识其实并没有站在巨人的肩膀上。打个不太恰当的比方来说<strong>这只是看到了巨人的肩膀</strong>，真正要站在巨人的肩膀上还是得靠自己脚踏实地走上巨人的肩膀才行。</p>
<p>在实际的践行中，才能更好地理解和领悟到所学知识的一些要点和难点，反过来提升和纠正认知，再采取下一步行动。这种行知、知行的反复才是真正提升认知和能力的途径。</p>
<h3 id="知到深处便是行；行到极致便是知。"><a href="#知到深处便是行；行到极致便是知。" class="headerlink" title="知到深处便是行；行到极致便是知。"></a>知到深处便是行；行到极致便是知。</h3><p>我逐渐开始理解我们老大为何如此推崇王阳明的知行合一，因为这就是他知行合一之后的感悟和认知。</p>
<p>所以，其他的不说了，多多看书，积极思考，踏实践行吧！</p>
<h2 id="聪明的学习方式"><a href="#聪明的学习方式" class="headerlink" title="聪明的学习方式"></a>聪明的学习方式</h2><p>今年在学习方式上也收获了很多。</p>
<h3 id="整体学习"><a href="#整体学习" class="headerlink" title="整体学习"></a>整体学习</h3><p>整体学习法是一本叫《如何高效学习》的书中学到的。作者史蒂芬杨在10天内搞定了线性代数，一年内搞定思念大学课程。这种学习达人的秘籍就是整体学习法。</p>
<p>他的方法我倒还没有机会践行，但是给我的启发已经开始起作用了。就是在学习技术的时候，不要上来就死扣文档，整体理解技术的实现方式和设计思想，通过画图的方式将这项技术整体勾勒出来。在理解了技术整体之后，学习其中的细节和用法会变得更加顺畅。</p>
<h3 id="策略学习"><a href="#策略学习" class="headerlink" title="策略学习"></a>策略学习</h3><p>策略学习这个东西在很多书中都有提到过。即我们看书和学习不要从头到尾开始看，必须带着目的去找到能解决当下问题和需求的知识看。</p>
<p>这是一种反常规的学习方式，一开始非常不习惯，总觉得自己缺了些什么。但这种以终为始的看书和学习方式，真的可以大大提高学习的效率。</p>
<p>我就在一周内看完了《JavaScript 高级程序设计》,用的就是策略学习的方法。核心是重点知识细看、次要知识可查。整体学习理解，明确学习重点和学习目标。</p>
<h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>当然，还是有一些高知识密度的干货是我们必须拿下的，这时候就可以使用深度学习的方式来进行攻坚战。</p>
<p>当然，深度学习也可以用到之前说的整体学习法来提高效率和理解。最近我很喜欢用画流程图和结构图的学习方式。</p>
<h1 id="今年简史"><a href="#今年简史" class="headerlink" title="今年简史"></a>今年简史</h1><p>说了一堆认知，说下今年的历程（篇幅较长）。</p>
<p>17年10月，我宝贝女儿的出生触发了我生活轨迹的改变，多米诺骨牌由此推动。</p>
<p>在孩子出生后，发现自己很难有时间大段大段的时间看书，于是买了喜马拉雅的会员听书。</p>
<p>在喜马拉雅最爱听《天天听好书》的一个栏目，它天天会推送一些好书。听了那么多书，多很多成长类书籍产生了兴趣。</p>
<p>借阅和购买了大量书籍阅读，像《富爸爸穷爸爸》、《财务自由之路》、《跃迁》、《刻意练习》、《关键对话》等。这些书籍给我打开了一个完全不同的世界。之前我看到的世界就是家庭生活、工作以及一些技术论坛，但是通过阅读我发现了很多人生的可能性，开始产生了对于现状的强烈不满感。</p>
<p>2018年4月，我毅然决定从安逸的小公司开发工作上裸辞。在家修整两月自我沉淀、安心带娃。在这期间我坚持每天5点起床，花4-5个小时更新技术博客。</p>
<p>2018年5月，我意外收到了饿了么的一位前辈的邀请去参见面试。当时饿了么对于我而言是前端工程师的圣地，是我理想中打开我新世界的最佳选择。在匆忙准备之后我去饿了么总部和面试官聊了半小时，但由于我前端基础不过关遗憾失败。</p>
<p>故事当然没那么快结束。由于当时我真的非常想加入一家优秀的互联网公司打开我对新世界的门窗，我继续和那位前辈沟通，请教我的技术缺陷和提升方式，我也一直很感激他给我的一系列建议。所以我在一个月的时间里学习完了《JavaScript 高级程序设计》、《算法》并且将150道 LeetCode 算法题刷了3遍。当时基本情况是早上起来就学习，一直到晚上七八点。</p>
<p>努力了一个月后，那位前辈给了我一次再去饿了么面试的机会。我坚定的告诉自己这次一定要成功。但故事并没那么顺利~由于当时饿了么工位不多，所以HR认为我并不胜任仅有的几个工位。虽然再次失败，但是我还是由衷的感谢那位前辈给我这么大的帮助。</p>
<p>由于刚好同学结婚，所以修整了一个星期。回到上海重整旗鼓开始投简历刚过一天。那位前辈又给了我一次面试上海链家的机会。这次机会我终于把握住了，6月份成功入职现在的公司。</p>
<p>在链家的6个月，让我成长了非常多。了解了互联网公司和业务团队的工作方式、看到了那么多优秀的同事、提升了大量的认知、学习到了很多做事的经验，这其中很多内容都整理在上文中了。这里也非常感谢军哥、彪哥和晖姐的帮助。我从一个小白逐渐的开始适应了互联网公司的工作方式和节奏。</p>
<p>就在18年的最后一个月，我又折腾了一下自己。报名参加了古典老师的个人战略课。白天忙着上班，晚上学习课程、参加小组讨论、周末还要按时交作业，把我给累的够呛。所幸这些折腾很有价值，古典老师的课程质量很高，我也遇到了非常帮的助教和同组小伙伴。我们在相互激励下完成了为期一个月的课程，在小组讨论中总能擦除很多火花，收获非常多。具体的收获我会在之后的笔记中整理出来，主要是理解工作的价值和定位，做好自己的职业生涯规划。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>2018 是我认知提升巨大的一年，带动着的是我生活现状的巨大改变。2019 年我对自己的期望是：</p>
<blockquote>
<p>远处看系统，近处看本质。<br>学习有策略，知行要合一。<br>产品看价值，妄念做减法。<br>技术懂原理，类比可迁移。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2018/05/10/数据集合常用 API 整理/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/10/数据集合常用 API 整理/" class="post-title-link" itemprop="url">常用数据集合 API 整理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-05-10 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-10T00:00:00+08:00">2018-05-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:20:56" itemprop="dateModified" datetime="2019-02-16T01:20:56+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近刷 LeetCode 题总是遇到 Array、Object、Set、Map 这类数据结构，虽然知道有些什么 API，但是每次用总是要查查 MDN 才放心。非常浪费时间，所以这里好好整理下这些数据集合的常用 API。</p>
</blockquote>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ul>
<li>Array.length 返回数组长度</li>
<li>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。传入类似数组对象及map回调方法，返回新数组。</li>
<li>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。返回修改后的数组（原数组）。</li>
<li>forEach() 方法对数组的每个元素执行一次提供的函数。</li>
<li>reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。</li>
<li>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</li>
<li>join() 方法将一个数组（或一个<a href="https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects" target="_blank" rel="noopener">类数组对象</a>）的所有元素连接成一个字符串并返回这个字符串。</li>
<li>keys() 方法返回一个新的Array迭代器，它包含数组中每个索引的键。</li>
<li>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li>
<li>数组操作：<ul>
<li>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是<strong>返回一个新数组</strong>。</li>
<li>pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</li>
<li>push() 方法将一个或多个元素添加到数组的末尾，并返回新数组的长度。</li>
<li>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</li>
<li>unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。</li>
<li>reverse() 方法将数组中元素的位置颠倒。</li>
<li>sort() 方法用<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">就地（ in-place ）的算法</a>对数组的元素进行排序，并返回数组。 sort 排序不一定是<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E6.80.A7" target="_blank" rel="noopener">稳定的</a>。默认排序顺序是根据字符串Unicode码点。会改变原数组，返回排序后的数组。</li>
<li>splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。可以用于删除也可用于插入数据。返回被删除的元素（集合）。</li>
<li>slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分<strong>浅拷贝到一个新数组对象。且原始数组不会被修改。</strong>截取内容的范围是 start &lt;= val &lt; end。可以使用 arr.slice() 对数组进行浅拷贝。</li>
</ul>
</li>
</ul>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ul>
<li>Object.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 可以通过 <code>Object.create(null)</code> 创建空对象。</li>
<li>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</li>
<li>Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</li>
<li>Object.seal() 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</li>
<li>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" title="for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。" target="_blank" rel="noopener"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul>
<li>size 属性将会返回<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" title="Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。" target="_blank" rel="noopener"><code>Set</code></a>对象中元素的个数。</li>
<li>add() 方法用来向一个 Set 对象的末尾添加一个指定的值。</li>
<li>clear() 方法用来清空一个 Set 对象中的所有元素。</li>
<li>delete() 方法可以从一个 Set 对象中删除指定的元素。</li>
<li>forEach 方法根据集合中元素的顺序，对每个元素都执行提供的 callback 函数一次。</li>
<li>has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul>
<li>size 可访问属性返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map" title="此页面仍未被本地化, 期待您的翻译!" target="_blank" rel="noopener"><code>Map</code></a> 对象的元素数量。</li>
<li>get() 方法用来获取一个 Map 对象中指定的元素。如果找不到返回 <code>undefined</code></li>
<li>set() 方法为 Map 对象添加一个指定键（key）和值（value）的新元素。</li>
<li>clear() 方法会移除Map对象中的所有元素。</li>
<li>delete() 方法用于移除 Map 对象中指定的元素。</li>
<li>forEach() ?方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数。</li>
<li>has() 方法返回一个布尔值，用来表明 map 中是否存在指定元素。</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>先就这些啦~整理出来以免每次用到的时候都去查 MDN （我都查烦了），这种常用的整理出来记在脑子里比较好。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2018/05/09/LeetCode 算法题刷题心得（JavaScript）/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/09/LeetCode 算法题刷题心得（JavaScript）/" class="post-title-link" itemprop="url">LeetCode 算法题刷题心得（JavaScript）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">2018-05-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:20:56" itemprop="dateModified" datetime="2019-02-16T01:20:56+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>花了十几天，把《算法》看了一遍然后重新 AC 了一遍 LeetCode 的题，收获颇丰。这次好好记录下心得。<br>我把所有做题的代码都放在 github 上以供参考。<br>项目地址：<a href="https://github.com/violetjack/LeetCodeACByJS" target="_blank" rel="noopener">https://github.com/violetjack/LeetCodeACByJS</a><br>题目地址：<a href="https://leetcode.com/problemset/top-interview-questions/" target="_blank" rel="noopener">https://leetcode.com/problemset/top-interview-questions/</a></p>
</blockquote>
<p>说来惭愧，之前写的《LeetCode 逻辑题分享》其实自己动手做的比较少，都是看解决方案。更加关键的是<strong>我没有系统地去学习过算法</strong>（自学的编程）。所以导致以下几个问题：</p>
<ul>
<li>看题不懂方法论，理解他人方案困难。</li>
<li>解题方法通过看别人的方案去归纳，照着抄。（其实都是有系统的算法写法的）</li>
<li>很多题目看了答案只是知其然而不知其所以然。</li>
<li>很多答案（讨论区的方案）是有错误的，却把它当正确答案来发。</li>
</ul>
<p>之后，我看了《算法（第4版）》一书，重新去做并且试着去 AC 题目，问题又是一堆堆的。所以这次比第一次刷题时间要久不少。</p>
<h1 id="各类题的解决方案"><a href="#各类题的解决方案" class="headerlink" title="各类题的解决方案"></a>各类题的解决方案</h1><p>话不多说，系统整理下解题的一些算法和解决方案</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树大多使用递归的方式左右两个元素向下递归。比如：</p>
<p><strong>计算二叉树最大深度</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>将二叉树以二维数组形式表现</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    helper(root, ans, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">node, ans, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (i == ans.length) ans.push([])</span><br><span class="line">    ans[i].push(node.val)</span><br><span class="line"></span><br><span class="line">    helper(node.left, ans, i + <span class="number">1</span>)</span><br><span class="line">    helper(node.right, ans, i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>都是通过递归方式逐层向下去查找二叉树数据。</p>
<h2 id="可能性问题"><a href="#可能性问题" class="headerlink" title="可能性问题"></a>可能性问题</h2><p>这类题一般是告诉你一组数据，然后求出可能性、最小值或最大值。比如：</p>
<p><strong>给定几种面额的硬币和一个总额，使用最少的硬币凑成这个总额。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span> (<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = amount + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>)</span><br><span class="line">    dp.fill(max)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用了动态规划（DP），将从 0 到目标额度所需的最小硬币数都列出来。</p>
<p><strong>求出从矩阵左上角走到右下角，且只能向右向下移动，一共有多少种可能性。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pos = <span class="keyword">new</span> <span class="built_in">Array</span>(m)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        pos[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pos[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        pos[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            pos[i][j] = pos[i - <span class="number">1</span>][j] + pos[i][j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这题就是使用了动态规划逐步列出每一格的可能性，最后返回右下角的可能性。</p>
<p><strong>获取给定数组连续元素累加最大值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = nums[<span class="number">0</span>], maxCount = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        count = <span class="built_in">Math</span>.max(count + nums[i], nums[i])</span><br><span class="line">        maxCount = <span class="built_in">Math</span>.max(maxCount, count)    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCount</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面这题通过不断对比最大值来保留并返回最大值。</p>
<p>其实，可能性问题使用<strong>动态规划</strong>要比使用 DFS、BFS 算法更加简单而容易理解。（我使用 DFS 经常报 TLE）</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>一般遇到的查找问题，如查找某个值一般会用到一下方法：</p>
<ul>
<li>排序算法（排序便于查找）</li>
<li>二分查找</li>
<li>索引移动查找（这个方法名自己想的，大概就这个意思~）</li>
</ul>
<p><strong>查找横向和纵向都递增的二维矩阵中的某个值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>, col = matrix[<span class="number">0</span>].length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] &gt; target &amp;&amp; col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            col--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target &amp;&amp; row &lt; matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">            row++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>先将位置定位在右上角，通过改变位置坐标来找到目标值。使用了索引移动查找法来找到结果。</p>
<p><strong>找到数组中最左边和最右边的某个数字所在位置</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> targetIndex = binarySearch(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (targetIndex == <span class="number">-1</span>) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">let</span> l = targetIndex, r = targetIndex</span><br><span class="line">    <span class="keyword">while</span>(l &gt; <span class="number">0</span> &amp;&amp; nums[l - <span class="number">1</span>] == target)&#123;</span><br><span class="line">        l--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[r + <span class="number">1</span>] == target)&#123;</span><br><span class="line">        r++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [l, r]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, val, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> mid = lo + <span class="built_in">parseInt</span>((hi - lo) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val &lt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, val, lo, mid - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; arr[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, val, mid + <span class="number">1</span>, hi)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这题使用<strong>二分法</strong>来查找到某个目标数字的索引值，然后<strong>索引移动法</strong>分别向左和向右查找字符。获取左右两侧的索引值返回。</p>
<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>所谓回文，就是正着读反着读是一样的。使用索引两边向中间移动的方式来判断是否为回文。</p>
<p><strong>找到给定字符串中某段最长的回文</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> singleCharLength = getPalLenByCenterChar(s, i, i)</span><br><span class="line">        <span class="keyword">let</span> doubleCharLength = getPalLenByCenterChar(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(singleCharLength, doubleCharLength)</span><br><span class="line">        <span class="keyword">if</span> (max &gt; maxLength) &#123;</span><br><span class="line">            maxLength = max</span><br><span class="line">            left = i - <span class="built_in">parseInt</span>((max - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            right = i + <span class="built_in">parseInt</span>(max / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.slice(left, right + <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPalLenByCenterChar</span>(<span class="params">s, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 中间值为两个字符，确保两个字符相等</span></span><br><span class="line">    <span class="keyword">if</span> (s[left] != s[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> right - left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; right &lt; s.length - <span class="number">1</span>) &#123;</span><br><span class="line">        left--</span><br><span class="line">        right++</span><br><span class="line">        <span class="keyword">if</span> (s[left] != s[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> right - left - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="路径题"><a href="#路径题" class="headerlink" title="路径题"></a>路径题</h2><p>路径题可以使用深度优先（DFS）和广度优先（BFS）算法来做。我比较常用的是使用 DFS 来做。通过递归将走过的路径进行标记来不断往前找到目标路径。如：</p>
<p><strong>通过给定单词在二维字母数组中查找是否能使用邻近字母组成这个单词</strong>(<a href="https://leetcode.com/problems/word-search-ii/description/" target="_blank" rel="noopener">212题</a>)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasWord = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findWords = <span class="function"><span class="keyword">function</span> (<span class="params">board, words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ans = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    hasWord = <span class="literal">false</span></span><br><span class="line">                    DFS(word, board, <span class="number">0</span>, j, i, <span class="string">""</span>)</span><br><span class="line">                    <span class="keyword">if</span> (hasWord) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ans.includes(word))</span><br><span class="line">                            ans.push(word)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DFS</span>(<span class="params">word, board, index, j, i, subStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word[index] == board[j][i]) &#123;</span><br><span class="line">        subStr += board[j][i]</span><br><span class="line">        board[j][i] = <span class="string">"*"</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; board.length - <span class="number">1</span>)</span><br><span class="line">            DFS(word, board, index + <span class="number">1</span>, j + <span class="number">1</span>, i, subStr)</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            DFS(word, board, index + <span class="number">1</span>, j - <span class="number">1</span>, i, subStr)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; board[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">            DFS(word, board, index + <span class="number">1</span>, j, i + <span class="number">1</span>, subStr)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            DFS(word, board, index + <span class="number">1</span>, j, i - <span class="number">1</span>, subStr)</span><br><span class="line">        board[j][i] = word[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= word.length || subStr == word) &#123;</span><br><span class="line">        hasWord = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 DFS 是一条路走到黑，如果每个元素都去使用 DFS 来找会出现超时的情况。如果条件允许（如查找递增数组）可以通过<strong>设置缓存</strong>来优化 DFS 查找超时问题。</p>
<p><strong>获取二维矩阵中最大相邻递增数组长度。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dirs = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">-1</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> longestIncreasingPath = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> m = matrix.length, n = matrix[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Array</span>(m)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> child = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br><span class="line">        child.fill(<span class="number">0</span>)</span><br><span class="line">        cache[i] = child</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> len = dfs(matrix, i, j, m, n, cache)</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, len)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">matrix, i, j, m, n, cache</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j]</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> dir <span class="keyword">of</span> dirs)&#123;</span><br><span class="line">        <span class="keyword">let</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> len = <span class="number">1</span> + dfs(matrix, x, y, m, n, cache)</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, len)</span><br><span class="line">    &#125;</span><br><span class="line">    cache[i][j] = max</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将已使用 DFS 查找过的长度放入缓存，如果有其他元素走 DFS 走到当前值，直接返回缓存最大值即可。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表从 JS 的角度来说就是一串对象使用指针连接的数据结构。合理使用 <code>next</code> 指针改变指向来完成对链表的一系列操作。如：</p>
<p><strong>链表的排序：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>, slow = head, fast = head</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        prev = slow</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prev.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> l1 = sortList(head)</span><br><span class="line">    <span class="keyword">let</span> l2 = sortList(slow)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(l1, l2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">null</span>)</span><br><span class="line">        p.next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">null</span>)</span><br><span class="line">        p.next = l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用了<strong>自上而下的归并排序方法</strong>对链表进行了排序。使用 <code>slow.next</code> 和 <code>fast.next.next</code> 两种速度获取链表节点，从而获取中间值。</p>
<p><strong>链表的倒序</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="literal">null</span>,cur = head</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextTmp = cur.next</span><br><span class="line">        cur.next = ans</span><br><span class="line">        ans = cur</span><br><span class="line">        cur = nextTmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序和查找算是算法中最重要的问题了。常用的排序算法有：</p>
<ul>
<li>插入排序</li>
<li>选择排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>计数排序</li>
</ul>
<p>更多排序算法的知识点可参考<a href="https://www.jianshu.com/p/1b4068ccd505" target="_blank" rel="noopener">《JS家的排序算法》</a>，文章作者图文并茂的讲解了各种排序算法，很容易理解。<br>举几个排序算法的栗子：</p>
<p><strong>求数组中第K大的值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> max = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[max]) max = j</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[a]</span><br><span class="line">    arr[a] = arr[b]</span><br><span class="line">    arr[b] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用了<strong>选择排序</strong>排列了前 K 个值得到结果。</p>
<p><strong>对有重复值的数组 <code>[2,0,2,1,1,0]</code> 排序</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    <span class="keyword">let</span> v = arr[lo]</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v) swap(arr, lt++, i++)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; v) swap(arr, i, gt--)</span><br><span class="line">        <span class="keyword">else</span> i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr, lo, lt - <span class="number">1</span>)</span><br><span class="line">    sort(arr, gt + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = arr[a]</span><br><span class="line">    arr[a] = arr[b]</span><br><span class="line">    arr[b] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种有重复值的使用<strong>三向切分的快速排序</strong>是非常好的解决方案。当然，<strong>计数排序</strong>法可是不错的选择。<br>还有之前提到的链表的排序使用的是<strong>归并排序</strong>。</p>
<h2 id="算术题"><a href="#算术题" class="headerlink" title="算术题"></a>算术题</h2><p>算术题看似简单，但是遇到最大的问题就是：如果使用累加、累成这种常熟级别的增长，遇到很大的数字会出现 TLE （超出时间限制）。所以，我们要用指数级别的增长来找到结果。如：</p>
<p><strong>计算 x 的 n 次方</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = -n</span><br><span class="line">        x = <span class="number">1</span> / x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? myPow(x * x, <span class="built_in">parseInt</span>(n / <span class="number">2</span>)) : x * myPow(x * x, <span class="built_in">parseInt</span>(n / <span class="number">2</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一开始我使用了 x<em>x 这么乘上 n 次，但是遇到 n 太大就直接超时了。使用以上方案：2^9^ = 2 </em> 4^4^ = 2 <em> 8^2^ = 2 </em> 64 = 128<br>直接从常熟级变化变为指数级变化，这一点在数学运算中是需要注意的。</p>
<p><strong>求 x 的平方根</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = x</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(l + (r - l) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt; x) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &lt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid + <span class="number">1</span>) * (mid + <span class="number">1</span>) &gt; x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这题使用二分法来找到结果。</p>
<h2 id="二进制问题"><a href="#二进制问题" class="headerlink" title="二进制问题"></a>二进制问题</h2><p>二进制问题，一般使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">按位运算符</a>和二进制转换 <code>Number.parseInt()</code> 和 <code>Number.prototype.toString()</code>来解决。</p>
<p><strong>将一个32位数字的二进制进行倒序</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = n.toString(<span class="number">2</span>).split(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">while</span>(t.length &lt; <span class="number">32</span>) t.unshift(<span class="string">"0"</span>); <span class="comment">// 插入足够的 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(t.reverse().join(<span class="string">""</span>), <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><p>讲了这么多，其实除了常用的排序、搜索，其他最常用的就是 DP、DFS、BFS 这三个算法了。可以这么说：掌握了排序和这三个算法，可以 AC 大多数的算法问题。这么牛逼的算法了解一下？</p>
<h2 id="简单说说几种排序和查找"><a href="#简单说说几种排序和查找" class="headerlink" title="简单说说几种排序和查找"></a>简单说说几种排序和查找</h2><ul>
<li><strong>冒泡排序</strong>：遍历数组，对比元素和后面相邻元素，如果当前元素大于后面元素，调换位置。这样从头遍历到尾，获取最后一位排序玩的元素。然后在 1 到 n - 1 中再次重复以上步骤。直到最后第一和第二个元素对比大小。是一种从后往前的排序。</li>
<li><p><strong>选择排序</strong>：遍历数组，找到最小的元素位置，与第一个元素调换位置，然后缩小范围从第二个元素开始遍历，如此重复到最后一个元素。可以从后往前也可以从前往后排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> min = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) min = j</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, min)</span><br><span class="line">        <span class="built_in">console</span>.log(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>插入排序</strong>：遍历数组，选中某一个元素，与前面相邻元素对比，如果当前元素小于之前元素，调换位置，继续对比直到当前元素前的元素小于当前元素（或者到最前面），如此对所有元素排序一遍。是一种从前往后的排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr, j, j - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(arr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>希尔排序</strong>：类似于插入排序，选中一个元素与元素前 n 个元素进行比大小和调换位置。之后再缩小 n 的值。这种方法可以减少插入排序中最小值在最后面，然后需要一个一个调换位置知道最前面这类问题。减少调换次数。是一种从前往后的排序。</p>
</li>
<li><p><strong>归并排序</strong>：在《算法》中提到了两种归并排序：一种是自上而下的归并排序。将数组不断二分到最小单位（1到2个元素）将他们进行排序，之后将前两个和后两个元素对比，如此往上最后完成整个数组的排序。还有一种自下而上的归并排序是直接将数组分割为若干个子数组进行排序然后合并。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aux = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> mid = lo + (<span class="built_in">parseInt</span>((hi - lo) / <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    sort(arr, lo, mid)</span><br><span class="line">    sort(arr, mid + <span class="number">1</span>, hi)</span><br><span class="line">    merge(arr, lo, mid, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, lo, mid, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = lo, j = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = arr[k]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) arr[k] = aux[j++]</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) arr[k] = aux[i++]</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) arr[k] = aux[j++]</span><br><span class="line">        <span class="keyword">else</span> arr[k] = aux[i++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>快速排序</strong>：选定第一个值为中间值，然后将小于中间值的元素放在中间值的左侧而大于中间值的元素放在中间值右侧，然后对两侧的元素分别再次切割，直到最小单位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo + <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> mid = partition(arr, lo, hi) <span class="comment">// 切分方法</span></span><br><span class="line">    sort(arr, lo, mid)</span><br><span class="line">    sort(arr, mid + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = lo, j = hi + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> v = arr[lo]</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[++i] &lt; v) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span>(v &lt; arr[--j]) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> ((i &gt;= j)) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, j)</span><br><span class="line">        <span class="built_in">console</span>.log(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, lo, j)</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>三向切分的快速排序</strong>：类似于快速排序，优化点在于如果某个元素等于切分元素，元素位置不变。最后小于切分元素的到左边，等于切分元素的根据数量放在中间，大于切分元素的放在右边。<strong>适用于有大量相同大小元素的数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    <span class="keyword">let</span> v = arr[lo]</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v) swap(arr, lt++, i++)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; v) swap(arr, i, gt--)</span><br><span class="line">        <span class="keyword">else</span> i++</span><br><span class="line">        <span class="built_in">console</span>.log(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr, lo, lt - <span class="number">1</span>)</span><br><span class="line">    sort(arr, gt + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>堆排序</strong>：堆排序可以说是一种利用堆的概念来排序的选择排序。使用优先队列返回最大值的特性逐个返回当前堆的最大值。</p>
</li>
<li><strong>计数排序</strong>：就是将数组中所有元素的出现次数保存在一个数组中，然后按照从小到大返回排序后的数组。</li>
<li><strong>桶排序</strong>：其实就是字符串排序的 LSD 和 MSD 排序。LSD 使用索引计数法从字符串右边向左边移动，根据当前值进行排序。而 MSD 是从左到右使用索引计数法来排序，在字符串第一个字符后，将字符串数组分为若干个相同首字符串的数组各自进行第二、第三次的 MSD 排序。</li>
<li><strong>二分查找</strong>： 对有序数组去中间值与目标值相比对。如果目标值小于中间值，取前一半数组继续二分。如果目标值大于中间值，取后一半数组继续二分。如果目标值等于中间值，命中！</li>
</ul>
<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>关于动态规划，可以看下<a href="http://www.cnblogs.com/little-YTMM/p/5372680.html" target="_blank" rel="noopener">详解动态规划——邹博讲动态规划</a>一文，其中讲了路径、硬币、最长子序列。都是 LeetCode 中有的题目。<br>我的理解：动态规划就是下一状态可以根据上一状态，或之前几个状态获取到的一种推理过程。</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索（DFS）就是选中某条从条件1到条件2的某条可能性进行搜索，之后返回搜索其他一条可能性，如此一条条升入。举个栗子，如果有5条路，那么 DFS 算法就是只排出一个斥候先走一条路走到底去侦察，如果走不通那么返回走下一条路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS（顶点v）</span><br><span class="line">&#123;</span><br><span class="line">  标记v为已遍历；</span><br><span class="line">  <span class="keyword">for</span>（对于每一个邻接v且未标记遍历的点u）</span><br><span class="line">      DFS（u）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DFS 使用的是递归的方式进行搜索的。</p>
<p><strong>示例：</strong>在二维字母矩阵中查找是否能够使用相邻字母组成目标单词。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span> (<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; board.length; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; board[<span class="number">0</span>].length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(board, word, y, x, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">board, word, y, x, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d == word.length) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> || y == board.length || x == board[y].length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (board[y][x] != word[d]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> tmp = board[y][x]</span><br><span class="line">    board[y][x] = <span class="string">"*"</span></span><br><span class="line">    <span class="keyword">let</span> exist = find(board, word, y, x + <span class="number">1</span>, d + <span class="number">1</span>)</span><br><span class="line">        || find(board, word, y, x - <span class="number">1</span>, d + <span class="number">1</span>)</span><br><span class="line">        || find(board, word, y + <span class="number">1</span>, x, d + <span class="number">1</span>)</span><br><span class="line">        || find(board, word, y - <span class="number">1</span>, x, d + <span class="number">1</span>)</span><br><span class="line">    board[y][x] = tmp</span><br><span class="line">    <span class="keyword">return</span> exist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索（BFS）就是将从条件1到条件2的所有可能性都列出来同步搜索的过程。适用于查找最短路径。举个栗子，如果有5条路，那么 BFS 算法就是分别向5条路排出斥候去侦察。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BFS()</span><br><span class="line">&#123;</span><br><span class="line">  输入起始点；</span><br><span class="line">  初始化所有顶点标记为未遍历；</span><br><span class="line">  初始化一个队列queue并将起始点放入队列；</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>（queue不为空）</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    从队列中删除一个顶点s并标记为已遍历； </span><br><span class="line">    将s邻接的所有还没遍历的点加入队列；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BFS是使用数组存储下一顶点的方式。</p>
<p><strong>示例：</strong>每次改变一次字母，通过给定数组中的单词，从单词 A 变为单词 B。（<a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">127题</a>）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; beginWord</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; endWord</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; wordList</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ladderLength = <span class="function"><span class="keyword">function</span> (<span class="params">beginWord, endWord, wordList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wordList.includes(endWord)) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        len = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    set.add(beginWord)</span><br><span class="line">    visited.add(beginWord)</span><br><span class="line">    <span class="keyword">while</span> (set.size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Set</span>([...set])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> tmp) &#123;</span><br><span class="line">            visited.add(w)</span><br><span class="line">            set.delete(w)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changeOneChar(w, endWord))</span><br><span class="line">                <span class="keyword">return</span> len + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> word <span class="keyword">of</span> wordList)&#123;</span><br><span class="line">                <span class="keyword">if</span> (changeOneChar(w, word) &amp;&amp; !visited.has(word))&#123;</span><br><span class="line">                    set.add(word)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeOneChar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">            count++</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>写下 AC 一遍题目之后的收获。</p>
<ul>
<li>知道了方法论，做起题来轻松了不少。</li>
<li>遇到问题多找轮子，一定有某种方法论可以用。</li>
<li>不要耍小聪明用一些奇巧淫技，思路不对再怎么绕都是浪费时间。</li>
<li>不要想着自己造轮子（特别是算法方面），绝大多数问题前辈一定有更好更完善的方案在。自己造轮子费时费事又没太大意义。</li>
<li>看答案和自己做是两回事，自己动手实现了才能算是会了。</li>
<li>算法之所以存在，就是用来适应某些场景、解决某类问题的。在对的场景选择对的算法才能体现算法的价值，不要滥用算法。</li>
<li>没必要把所有算法都精通，但起码在遇到问题时可以找到最优算法解决问题。即知道算法的存在及其用途，按需深入学习。</li>
</ul>
<p>其实刷算法题还是很有趣的事情，之后计划把 <a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">LeetCode 题库</a>中的所有问题都刷一遍~</p>
<p><strong>PS：本文以及相关项目中有任何错误或者可以改进的地方，还请提出。共同进步~</strong></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://violetjack.github.io/2018/04/13/element 源码学习六 —— Carousel 走马灯学习/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VioletJack"/>
      <meta itemprop="description" content="Violetjack 的个人博客，记录了一些技术笔记和思考。"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VioletJack 技术日志"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/13/element 源码学习六 —— Carousel 走马灯学习/" class="post-title-link" itemprop="url">element 源码学习六 —— Carousel 走马灯学习</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-04-13 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-13T00:00:00+08:00">2018-04-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2019-02-16 01:20:56" itemprop="dateModified" datetime="2019-02-16T01:20:56+08:00">2019-02-16</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>走马灯功能在展示图片时经常用到，而 element 中提供了 Carousel 组件。出于好奇学习一下它的实现原理。<br>具体的功能详情请查阅<a href="http://element-cn.eleme.io/#/zh-CN/component/carousel" target="_blank" rel="noopener">官方文档</a>。<br>关于组件属性，该组件提供了组件高度、索引、指示器、切换时间等一众配置，这个只要动手试一遍都能理解。<br>关于事件，提供了一个 <code>change</code> 事件。可以通过 <code>v-on:change=&quot;changeFun&quot;</code> 事件绑定来监听。该事件传递了两个参数：当前页索引和前一页索引。参考源码中的 <code>$emit</code> 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  activeIndex(val, oldVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resetItemPosition(oldVal);</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, val, oldVal);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>关于方法，组件提供了三个方法用于操作组件页面的切换。使用方法是通过 $ref <a href="https://cn.vuejs.org/v2/guide/components.html#子组件引用" target="_blank" rel="noopener">子组件引用</a>来访问子组件，执行其方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设为 el-carousel 设置了 ref="car"</span></span><br><span class="line"><span class="comment">// setActiveItem	手动切换幻灯片	需要切换的幻灯片的索引，从 0 开始；或相应 el-carousel-item 的 name 属性值</span></span><br><span class="line"><span class="comment">// prev	切换至上一张幻灯片</span></span><br><span class="line"><span class="comment">// next 切换至下一张幻灯片</span></span><br><span class="line">pre() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.car.prev()</span><br><span class="line">&#125;,</span><br><span class="line">next() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.car.next()</span><br><span class="line">&#125;,</span><br><span class="line">first() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.car.setActiveItem(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="源码位置"><a href="#源码位置" class="headerlink" title="源码位置"></a>源码位置</h1><p>Carousel 的源码位于 <code>package/carousel/</code> 目录下。源码目录如下：<br><img src="https://upload-images.jianshu.io/upload_images/1987062-08d5f9051a1f9174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源码目录"></p>
<p>简单说下目录内容：</p>
<ul>
<li><strong>item.vue</strong> carousel-item 组件代码</li>
<li><strong>main.vue</strong> carousel 组件代码</li>
<li><strong>_index.js</strong> 导出 carousel-item 和 carousel </li>
<li><strong>cooking.conf.js</strong> cooking 配置</li>
<li><strong>index.js</strong> 导出 carousel 组件</li>
<li><strong>package.json</strong> 组件信息</li>
<li><strong>index.js</strong> 导出 carousel-item 组件</li>
</ul>
<p>其实主要就是两个 <code>.vue</code> 文件，其他都是些配置、导出的功能文件，这里可以忽略不看~</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>老规矩，我们通过几个问题切入去看源代码。</p>
<h2 id="1-基本原理：页面切换-指示器-切换按钮的实现"><a href="#1-基本原理：页面切换-指示器-切换按钮的实现" class="headerlink" title="1. 基本原理：页面切换 + 指示器 + 切换按钮的实现"></a>1. 基本原理：页面切换 + 指示器 + 切换按钮的实现</h2><h3 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h3><p>看了一下 DOM 的 Elements 排列，<strong>发现页面切换使用的是 transform 2D 转换和 transition 过渡。</strong><br>一般页面切换其实是几个页面使用 translateX 进行位移切换。<br><img src="https://upload-images.jianshu.io/upload_images/1987062-eb167cd5660779e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一般页面结构"></p>
<p>而卡片变化切换同时使用了 translateX 位移和 scale 缩放实现中间一张卡最大，左右卡片小的效果的。<br><img src="https://upload-images.jianshu.io/upload_images/1987062-974136def5c81522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卡片化"></p>
<p>而卡片的层叠使用 z-index 值得大小来实现。<br><strong>所以，逻辑计算只需要根据当前显示页面计算下每个页面的位移值。</strong>而 carousel-item 中也的确有计算的逻辑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item.vue</span></span><br><span class="line"><span class="comment">// index 当前 item 索引</span></span><br><span class="line"><span class="comment">// activeIndex 激活的 item 索引</span></span><br><span class="line"><span class="comment">// oldIndex 之前 item 索引</span></span><br><span class="line">translateItem(index, activeIndex, oldIndex) &#123;</span><br><span class="line">  <span class="comment">// 获取父元素宽度 https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth</span></span><br><span class="line">  <span class="keyword">const</span> parentWidth = <span class="keyword">this</span>.$parent.$el.offsetWidth;</span><br><span class="line">  <span class="comment">// 获取 item 页面数量</span></span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.$parent.items.length;</span><br><span class="line">  <span class="comment">// 判断是否需要过渡动画 class</span></span><br><span class="line">  <span class="comment">// .el-carousel__item.is-animating &#123;</span></span><br><span class="line">  <span class="comment">//  transition: transform 0.4s ease-in-out;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.$parent.type !== <span class="string">"card"</span> &amp;&amp; oldIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.animating = index === activeIndex || index === oldIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理 index</span></span><br><span class="line">  <span class="keyword">if</span> (index !== activeIndex &amp;&amp; length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    index = <span class="keyword">this</span>.processIndex(index, activeIndex, length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.$parent.type === <span class="string">"card"</span>) &#123;</span><br><span class="line">    <span class="comment">// 卡片化</span></span><br><span class="line">    <span class="keyword">this</span>.inStage = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.abs(index - activeIndex)) &lt;= <span class="number">1</span>; <span class="comment">// 激活组件及其前后组件定义 cursor: pointer; z-index: 1;</span></span><br><span class="line">    <span class="keyword">this</span>.active = index === activeIndex; <span class="comment">// 激活 class</span></span><br><span class="line">    <span class="comment">// 计算卡片化偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.translate = <span class="keyword">this</span>.calculateTranslate(</span><br><span class="line">      index,</span><br><span class="line">      activeIndex,</span><br><span class="line">      parentWidth</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 激活卡片不缩放，其他卡片缩放为 0.83</span></span><br><span class="line">    <span class="keyword">this</span>.scale = <span class="keyword">this</span>.active ? <span class="number">1</span> : CARD_SCALE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非卡片化</span></span><br><span class="line">    <span class="keyword">this</span>.active = index === activeIndex; <span class="comment">// 激活 class</span></span><br><span class="line">    <span class="keyword">this</span>.translate = parentWidth * (index - activeIndex); <span class="comment">// 计算位移 根据父组件宽度计算</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算完后显示</span></span><br><span class="line">  <span class="keyword">this</span>.ready = <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h3 id="指示器"><a href="#指示器" class="headerlink" title="指示器"></a>指示器</h3><p>指示器就是多个 button 组成的横向列表，根据当前显示页面修改某个指示器背景颜色。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-carousel__indicators"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">"indicatorPosition !== 'none'"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">"&#123; 'el-carousel__indicators--labels': hasLabel, 'el-carousel__indicators--outside': indicatorPosition === 'outside' || type === 'card' &#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-carousel__indicator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"&#123; 'is-active': index === activeIndex &#125;"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">mouseenter</span>=<span class="string">"throttledIndicatorHover(index)"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click.stop</span>=<span class="string">"handleIndicatorClick(index)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"el-carousel__button"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"hasLabel"</span>&gt;</span>&#123;&#123; item.label &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="切换按钮"><a href="#切换按钮" class="headerlink" title="切换按钮"></a>切换按钮</h3><p>切换按钮其实就是两个 absolute 的按钮，点击实现页面切换即可。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"carousel-arrow-left"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"arrow !== 'never'"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-show</span>=<span class="string">"arrow === 'always' || hover"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">mouseenter</span>=<span class="string">"handleButtonEnter('left')"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">mouseleave</span>=<span class="string">"handleButtonLeave"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click.stop</span>=<span class="string">"throttledArrowClick(activeIndex - 1)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-carousel__arrow el-carousel__arrow--left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-arrow-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"carousel-arrow-right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"arrow !== 'never'"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-show</span>=<span class="string">"arrow === 'always' || hover"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">mouseenter</span>=<span class="string">"handleButtonEnter('right')"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">mouseleave</span>=<span class="string">"handleButtonLeave"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click.stop</span>=<span class="string">"throttledArrowClick(activeIndex + 1)"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-carousel__arrow el-carousel__arrow--right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-arrow-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里要注意的就是按钮外包裹了 <transition> 标签来实现按钮进入和离开的过渡效果。</transition></p>
<h2 id="2-页面切换动画如何实现？"><a href="#2-页面切换动画如何实现？" class="headerlink" title="2. 页面切换动画如何实现？"></a>2. 页面切换动画如何实现？</h2><p>其实在基本原理里面都提到了，可以从源码中找到两个样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 内联样式</span><br><span class="line"><span class="selector-tag">element</span><span class="selector-class">.style</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(888.56px) <span class="built_in">scale</span>(0.83);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 过渡样式</span><br><span class="line"><span class="selector-class">.is-animating</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.4s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态情况下，使用 transitionX 维持页面位置，显示当前页面。过渡行为时，加入 0.4 秒的 transition 过渡效果。</p>
<h2 id="3-卡片化如何实现效果？"><a href="#3-卡片化如何实现效果？" class="headerlink" title="3. 卡片化如何实现效果？"></a>3. 卡片化如何实现效果？</h2><p>卡片化切换其实和一般的切换差不多，只是显示卡片从一张变为三张。中间的卡片 z-index 为 2，而左右的卡片 z-index 为 1，从而实现中间卡片在前面的样式。而计算三张卡片位置的方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">calculateTranslate(index, activeIndex, parentWidth) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.inStage) &#123;</span><br><span class="line">    <span class="keyword">return</span> parentWidth * ((<span class="number">2</span> - CARD_SCALE) * (index - activeIndex) + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; activeIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span> -(<span class="number">1</span> + CARD_SCALE) * parentWidth / <span class="number">4</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span> + CARD_SCALE) * parentWidth / <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>而卡片的宽度为容器宽度的一半~左右两边的卡片缩放了 83% 。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.el-carousel__item--card</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.4s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">element</span><span class="selector-class">.style</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-39.44px) <span class="built_in">scale</span>(0.83)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结下：</p>
<ul>
<li>显示三张卡片。</li>
<li>三张卡片高度跟随容器，宽度为容器的 50%。</li>
<li>左右两张卡片缩放了 83% 大小。</li>
<li>左右两张卡片 z-index 为 1；中间卡片 z-index 为 2。</li>
</ul>
<h2 id="4-按钮出现和消失的效果如何实现？"><a href="#4-按钮出现和消失的效果如何实现？" class="headerlink" title="4. 按钮出现和消失的效果如何实现？"></a>4. 按钮出现和消失的效果如何实现？</h2><p>使用了 vue 的 transition 标签来实现。具体效果为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.el-carousel__arrow</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">36px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">36px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(31, 45, 61, 0.11);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.carousel-arrow-left-enter</span>,</span><br><span class="line"><span class="selector-class">.carousel-arrow-left-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%) <span class="built_in">translateX</span>(-10px);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.carousel-arrow-right-enter</span>,</span><br><span class="line"><span class="selector-class">.carousel-arrow-right-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%) <span class="built_in">translateX</span>(10px);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现的效果为：左边箭头向从左边  10px 位置进入和离开，而右边箭头从右边 10px 位置进入和离开。而 <code>translateY</code> 是为了垂直居中。</p>
<h2 id="5-如何实现自动切换功能？"><a href="#5-如何实现自动切换功能？" class="headerlink" title="5. 如何实现自动切换功能？"></a>5. 如何实现自动切换功能？</h2><p>使用 setInterval 方法来实现定时向后切换页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">playSlides() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.activeIndex &lt; <span class="keyword">this</span>.items.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.activeIndex++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是最后一页则跳转到第一页</span></span><br><span class="line">    <span class="keyword">this</span>.activeIndex = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 取消 timer</span></span><br><span class="line">pauseTimer() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 开始 timer</span></span><br><span class="line">startTimer() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.interval &lt;= <span class="number">0</span> || !<span class="keyword">this</span>.autoplay) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="keyword">this</span>.playSlides, <span class="keyword">this</span>.interval);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h1 id="自己实现个走马灯玩玩"><a href="#自己实现个走马灯玩玩" class="headerlink" title="自己实现个走马灯玩玩~"></a>自己实现个走马灯玩玩~</h1><p>学以致用，这里写个简单的 demo，实现下走马灯功能。<br>例一：<strong><a href="https://jsfiddle.net/VioletJack/zkjtchL2/6/" target="_blank" rel="noopener">走马灯效果</a></strong><br>例二：<strong><a href="https://jsfiddle.net/VioletJack/jfvf6xmq/3/" target="_blank" rel="noopener">卡片化走马灯效果</a></strong><br>其中，例一和例二实现了走马灯和卡片化的自动切换、手动切换、切换效果。<br>这里留了一个问题待解决：</p>
<ul>
<li>走马灯中第一页和最后一页的切换如何做到更好？</li>
</ul>
<p>这些问题将会尽快解决！</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>至此，我们了解了走马灯的实现原理，以及一些小功能的实现。最后也用两个例子证明了我们的分析。</p>
<h1 id="Vue-实验室"><a href="#Vue-实验室" class="headerlink" title="Vue 实验室"></a>Vue 实验室</h1><p>《Vue 实验室》 至今也写了不少了，作者将在把最后几篇计划中的博客写完后，以当前的知识认知水平重新改进《Vue 实验室》往期的文章，并整理到 gitbook 中便于读者阅读，敬请期待。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="VioletJack"/>
            
              <p class="site-author-name" itemprop="name">VioletJack</p>
              <p class="site-description motion-element" itemprop="description">Violetjack 的个人博客，记录了一些技术笔记和思考。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">47</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">Tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/violetjack" title="GitHub &rarr; https://github.com/violetjack" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:violetjack@foxmail.com" title="E-Mail &rarr; mailto:violetjack@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/u/2640909603/home" title="Weibo &rarr; https://weibo.com/u/2640909603/home" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/54ae4af3a98d" title="JianShu &rarr; https://www.jianshu.com/u/54ae4af3a98d" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>JianShu</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VioletJack</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.5.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
